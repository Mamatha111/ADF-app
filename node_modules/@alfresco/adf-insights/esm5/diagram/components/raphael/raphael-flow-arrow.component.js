/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Directive, ElementRef, EventEmitter, Input, Output } from '@angular/core';
import { Polyline } from './polyline';
import { RaphaelBase } from './raphael-base';
import { RaphaelService } from './raphael.service';
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
var RaphaelFlowArrowDirective = /** @class */ (function (_super) {
    tslib_1.__extends(RaphaelFlowArrowDirective, _super);
    function RaphaelFlowArrowDirective(elementRef, raphaelService) {
        var _this = _super.call(this, elementRef, raphaelService) || this;
        _this.elementRef = elementRef;
        _this.error = new EventEmitter();
        _this.ARROW_WIDTH = 4;
        _this.SEQUENCE_FLOW_STROKE = 1.5;
        return _this;
    }
    /**
     * @return {?}
     */
    RaphaelFlowArrowDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.draw(this.flow);
    };
    /**
     * @param {?} flow
     * @return {?}
     */
    RaphaelFlowArrowDirective.prototype.draw = /**
     * @param {?} flow
     * @return {?}
     */
    function (flow) {
        /** @type {?} */
        var line = this.drawLine(flow);
        this.drawArrow(line);
    };
    /**
     * @param {?} flow
     * @return {?}
     */
    RaphaelFlowArrowDirective.prototype.drawLine = /**
     * @param {?} flow
     * @return {?}
     */
    function (flow) {
        /** @type {?} */
        var polyline = new Polyline(flow.id, flow.waypoints, this.SEQUENCE_FLOW_STROKE, this.paper);
        polyline.element = this.paper.path(polyline.path);
        polyline.element.attr({ 'stroke-width': this.SEQUENCE_FLOW_STROKE });
        polyline.element.attr({ 'stroke': '#585858' });
        polyline.element.node.id = this.flow.id;
        /** @type {?} */
        var lastLineIndex = polyline.getLinesCount() - 1;
        /** @type {?} */
        var line = polyline.getLine(lastLineIndex);
        return line;
    };
    /**
     * @param {?} line
     * @return {?}
     */
    RaphaelFlowArrowDirective.prototype.drawArrow = /**
     * @param {?} line
     * @return {?}
     */
    function (line) {
        /** @type {?} */
        var doubleArrowWidth = 2 * this.ARROW_WIDTH;
        /** @type {?} */
        var width = this.ARROW_WIDTH / 2 + .5;
        /** @type {?} */
        var arrowHead = this.paper.path('M0 0L-' + width + '-' + doubleArrowWidth + 'L' + width + ' -' + doubleArrowWidth + 'z');
        arrowHead.transform('t' + line.x2 + ',' + line.y2);
        /** @type {?} */
        var angle = Raphael.deg(line.angle - Math.PI / 2);
        arrowHead.transform('...r' + angle + ' 0 0');
        arrowHead.attr('fill', '#585858');
        arrowHead.attr('stroke-width', this.SEQUENCE_FLOW_STROKE);
        arrowHead.attr('stroke', '#585858');
    };
    RaphaelFlowArrowDirective.decorators = [
        { type: Directive, args: [{ selector: 'adf-raphael-flow-arrow, raphael-flow-arrow' },] }
    ];
    /** @nocollapse */
    RaphaelFlowArrowDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: RaphaelService }
    ]; };
    RaphaelFlowArrowDirective.propDecorators = {
        paper: [{ type: Input }],
        flow: [{ type: Input }],
        error: [{ type: Output }]
    };
    return RaphaelFlowArrowDirective;
}(RaphaelBase));
export { RaphaelFlowArrowDirective };
if (false) {
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.paper;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.flow;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.error;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.ARROW_WIDTH;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.SEQUENCE_FLOW_STROKE;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.elementRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFwaGFlbC1mbG93LWFycm93LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtaW5zaWdodHMvIiwic291cmNlcyI6WyJkaWFncmFtL2NvbXBvbmVudHMvcmFwaGFlbC9yYXBoYWVsLWZsb3ctYXJyb3cuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFVLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzRixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7Ozs7QUFPbkQ7SUFDK0MscURBQVc7SUFhdEQsbUNBQW1CLFVBQXNCLEVBQzdCLGNBQThCO1FBRDFDLFlBRUksa0JBQU0sVUFBVSxFQUFFLGNBQWMsQ0FBQyxTQUNwQztRQUhrQixnQkFBVSxHQUFWLFVBQVUsQ0FBWTtRQUx6QyxXQUFLLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUUzQixpQkFBVyxHQUFHLENBQUMsQ0FBQztRQUNoQiwwQkFBb0IsR0FBRyxHQUFHLENBQUM7O0lBSzNCLENBQUM7Ozs7SUFFRCw0Q0FBUTs7O0lBQVI7UUFFSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QixDQUFDOzs7OztJQUVNLHdDQUFJOzs7O0lBQVgsVUFBWSxJQUFTOztZQUNiLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztRQUM5QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3pCLENBQUM7Ozs7O0lBRU0sNENBQVE7Ozs7SUFBZixVQUFnQixJQUFTOztZQUNqQixRQUFRLEdBQUcsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQzNGLFFBQVEsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xELFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsRUFBQyxDQUFDLENBQUM7UUFDbkUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBQyxRQUFRLEVBQUUsU0FBUyxFQUFDLENBQUMsQ0FBQztRQUU3QyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7O1lBRXBDLGFBQWEsR0FBRyxRQUFRLENBQUMsYUFBYSxFQUFFLEdBQUcsQ0FBQzs7WUFDNUMsSUFBSSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO1FBQzFDLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Ozs7O0lBRU0sNkNBQVM7Ozs7SUFBaEIsVUFBaUIsSUFBUzs7WUFDbEIsZ0JBQWdCLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXOztZQUN2QyxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLEdBQUcsRUFBRTs7WUFDakMsU0FBUyxHQUFRLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLGdCQUFnQixHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsSUFBSSxHQUFHLGdCQUFnQixHQUFHLEdBQUcsQ0FBQztRQUU3SCxTQUFTLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7O1lBQy9DLEtBQUssR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDakQsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDO1FBRTdDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBRWxDLFNBQVMsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQzFELFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBRXhDLENBQUM7O2dCQXhESixTQUFTLFNBQUMsRUFBQyxRQUFRLEVBQUUsNENBQTRDLEVBQUM7Ozs7Z0JBVi9DLFVBQVU7Z0JBR3JCLGNBQWM7Ozt3QkFTbEIsS0FBSzt1QkFHTCxLQUFLO3dCQUdMLE1BQU07O0lBaURYLGdDQUFDO0NBQUEsQUF6REQsQ0FDK0MsV0FBVyxHQXdEekQ7U0F4RFkseUJBQXlCOzs7SUFDbEMsMENBQ1c7O0lBRVgseUNBQ1U7O0lBRVYsMENBQzJCOztJQUUzQixnREFBZ0I7O0lBQ2hCLHlEQUEyQjs7SUFFZiwrQ0FBNkIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4vcG9seWxpbmUnO1xuaW1wb3J0IHsgUmFwaGFlbEJhc2UgfSBmcm9tICcuL3JhcGhhZWwtYmFzZSc7XG5pbXBvcnQgeyBSYXBoYWVsU2VydmljZSB9IGZyb20gJy4vcmFwaGFlbC5zZXJ2aWNlJztcblxuZGVjbGFyZSBsZXQgUmFwaGFlbDogYW55O1xuXG4vKipcbiAqIERpcmVjdGl2ZSBzZWxlY3RvcnMgd2l0aG91dCBhZGYtIHByZWZpeCB3aWxsIGJlIGRlcHJlY2F0ZWQgb24gMy4wLjBcbiAqL1xuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdhZGYtcmFwaGFlbC1mbG93LWFycm93LCByYXBoYWVsLWZsb3ctYXJyb3cnfSlcbmV4cG9ydCBjbGFzcyBSYXBoYWVsRmxvd0Fycm93RGlyZWN0aXZlIGV4dGVuZHMgUmFwaGFlbEJhc2UgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIEBJbnB1dCgpXG4gICAgcGFwZXI6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgZmxvdzogYW55O1xuXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3IgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBBUlJPV19XSURUSCA9IDQ7XG4gICAgU0VRVUVOQ0VfRkxPV19TVFJPS0UgPSAxLjU7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICByYXBoYWVsU2VydmljZTogUmFwaGFlbFNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudFJlZiwgcmFwaGFlbFNlcnZpY2UpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuXG4gICAgICAgIHRoaXMuZHJhdyh0aGlzLmZsb3cpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3KGZsb3c6IGFueSkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuZHJhd0xpbmUoZmxvdyk7XG4gICAgICAgIHRoaXMuZHJhd0Fycm93KGxpbmUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3TGluZShmbG93OiBhbnkpIHtcbiAgICAgICAgbGV0IHBvbHlsaW5lID0gbmV3IFBvbHlsaW5lKGZsb3cuaWQsIGZsb3cud2F5cG9pbnRzLCB0aGlzLlNFUVVFTkNFX0ZMT1dfU1RST0tFLCB0aGlzLnBhcGVyKTtcbiAgICAgICAgcG9seWxpbmUuZWxlbWVudCA9IHRoaXMucGFwZXIucGF0aChwb2x5bGluZS5wYXRoKTtcbiAgICAgICAgcG9seWxpbmUuZWxlbWVudC5hdHRyKHsnc3Ryb2tlLXdpZHRoJzogdGhpcy5TRVFVRU5DRV9GTE9XX1NUUk9LRX0pO1xuICAgICAgICBwb2x5bGluZS5lbGVtZW50LmF0dHIoeydzdHJva2UnOiAnIzU4NTg1OCd9KTtcblxuICAgICAgICBwb2x5bGluZS5lbGVtZW50Lm5vZGUuaWQgPSB0aGlzLmZsb3cuaWQ7XG5cbiAgICAgICAgbGV0IGxhc3RMaW5lSW5kZXggPSBwb2x5bGluZS5nZXRMaW5lc0NvdW50KCkgLSAxO1xuICAgICAgICBsZXQgbGluZSA9IHBvbHlsaW5lLmdldExpbmUobGFzdExpbmVJbmRleCk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3QXJyb3cobGluZTogYW55KSB7XG4gICAgICAgIGxldCBkb3VibGVBcnJvd1dpZHRoID0gMiAqIHRoaXMuQVJST1dfV0lEVEg7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMuQVJST1dfV0lEVEggLyAyICsgLjU7XG4gICAgICAgIGxldCBhcnJvd0hlYWQ6IGFueSA9IHRoaXMucGFwZXIucGF0aCgnTTAgMEwtJyArIHdpZHRoICsgJy0nICsgZG91YmxlQXJyb3dXaWR0aCArICdMJyArIHdpZHRoICsgJyAtJyArIGRvdWJsZUFycm93V2lkdGggKyAneicpO1xuXG4gICAgICAgIGFycm93SGVhZC50cmFuc2Zvcm0oJ3QnICsgbGluZS54MiArICcsJyArIGxpbmUueTIpO1xuICAgICAgICBsZXQgYW5nbGUgPSBSYXBoYWVsLmRlZyhsaW5lLmFuZ2xlIC0gTWF0aC5QSSAvIDIpO1xuICAgICAgICBhcnJvd0hlYWQudHJhbnNmb3JtKCcuLi5yJyArIGFuZ2xlICsgJyAwIDAnKTtcblxuICAgICAgICBhcnJvd0hlYWQuYXR0cignZmlsbCcsICcjNTg1ODU4Jyk7XG5cbiAgICAgICAgYXJyb3dIZWFkLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHRoaXMuU0VRVUVOQ0VfRkxPV19TVFJPS0UpO1xuICAgICAgICBhcnJvd0hlYWQuYXR0cignc3Ryb2tlJywgJyM1ODU4NTgnKTtcblxuICAgIH1cbn1cbiJdfQ==