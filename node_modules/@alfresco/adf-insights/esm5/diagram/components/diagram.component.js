/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { DiagramModel } from '../models/diagram/diagram.model';
import { DiagramColorService } from '../services/diagram-color.service';
import { DiagramsService } from '../services/diagrams.service';
import { RaphaelService } from './raphael/raphael.service';
var DiagramComponent = /** @class */ (function () {
    function DiagramComponent(diagramColorService, raphaelService, diagramsService) {
        this.diagramColorService = diagramColorService;
        this.raphaelService = raphaelService;
        this.diagramsService = diagramsService;
        this.metricType = '';
        this.width = 1000;
        this.height = 500;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.PADDING_WIDTH = 60;
        this.PADDING_HEIGHT = 60;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    DiagramComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.reset();
        this.diagramColorService.setTotalColors(this.metricColor);
        if (this.processDefinitionId) {
            this.getProcessDefinitionModel(this.processDefinitionId);
        }
        else {
            this.getRunningProcessDefinitionModel(this.processInstanceId);
        }
    };
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    DiagramComponent.prototype.getRunningProcessDefinitionModel = /**
     * @param {?} processInstanceId
     * @return {?}
     */
    function (processInstanceId) {
        var _this = this;
        this.diagramsService.getRunningProcessDefinitionModel(processInstanceId).subscribe(function (res) {
            _this.diagram = new DiagramModel(res);
            _this.raphaelService.setting(_this.diagram.diagramWidth + _this.PADDING_WIDTH, _this.diagram.diagramHeight + _this.PADDING_HEIGHT);
            _this.setMetricValueToDiagramElement(_this.diagram, _this.metricPercentages, _this.metricType);
            _this.success.emit(res);
        }, function (err) {
            _this.error.emit(err);
        });
    };
    /**
     * @param {?} processDefinitionId
     * @return {?}
     */
    DiagramComponent.prototype.getProcessDefinitionModel = /**
     * @param {?} processDefinitionId
     * @return {?}
     */
    function (processDefinitionId) {
        var _this = this;
        this.diagramsService.getProcessDefinitionModel(processDefinitionId).subscribe(function (res) {
            _this.diagram = new DiagramModel(res);
            _this.raphaelService.setting(_this.diagram.diagramWidth + _this.PADDING_WIDTH, _this.diagram.diagramHeight + _this.PADDING_HEIGHT);
            _this.setMetricValueToDiagramElement(_this.diagram, _this.metricPercentages, _this.metricType);
            _this.success.emit(res);
        }, function (err) {
            _this.error.emit(err);
        });
    };
    /**
     * @param {?} diagram
     * @param {?} metrics
     * @param {?} metricType
     * @return {?}
     */
    DiagramComponent.prototype.setMetricValueToDiagramElement = /**
     * @param {?} diagram
     * @param {?} metrics
     * @param {?} metricType
     * @return {?}
     */
    function (diagram, metrics, metricType) {
        var _loop_1 = function (key) {
            if (metrics.hasOwnProperty(key)) {
                /** @type {?} */
                var foundElement = diagram.elements.find(function (element) { return element.id === key; });
                if (foundElement) {
                    foundElement.value = metrics[key];
                    foundElement.dataType = metricType;
                }
            }
        };
        for (var key in metrics) {
            _loop_1(key);
        }
    };
    /**
     * @return {?}
     */
    DiagramComponent.prototype.reset = /**
     * @return {?}
     */
    function () {
        this.raphaelService.reset();
    };
    DiagramComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-diagram',
                    template: "<div *ngIf=\"diagram\" class=\"diagram\">\n    <div *ngFor=\"let element of diagram.elements\">\n        <div [ngSwitch]=\"element.type\">\n            <div *ngSwitchCase=\"'StartEvent'\">\n                <diagram-start-event [data]=\"element\"></diagram-start-event>\n            </div>\n            <div *ngSwitchCase=\"'ExclusiveGateway'\">\n                <diagram-exclusive-gateway [data]=\"element\"></diagram-exclusive-gateway>\n            </div>\n            <div *ngSwitchCase=\"'InclusiveGateway'\">\n                <diagram-inclusive-gateway [data]=\"element\"></diagram-inclusive-gateway>\n            </div>\n            <div *ngSwitchCase=\"'EventGateway'\">\n                <diagram-event-gateway [data]=\"element\"></diagram-event-gateway>\n            </div>\n            <div *ngSwitchCase=\"'ParallelGateway'\">\n                <diagram-parallel-gateway [data]=\"element\"></diagram-parallel-gateway>\n            </div>\n            <div *ngSwitchCase=\"'EndEvent'\">\n                <diagram-end-event [data]=\"element\"></diagram-end-event>\n            </div>\n            <div *ngSwitchCase=\"'UserTask'\">\n                <diagram-user-task [data]=\"element\"></diagram-user-task>\n            </div>\n            <div *ngSwitchCase=\"'ManualTask'\">\n                <diagram-manual-task [data]=\"element\"></diagram-manual-task>\n            </div>\n            <div *ngSwitchCase=\"'ServiceTask'\">\n                <diagram-container-service-task [data]=\"element\"></diagram-container-service-task>\n            </div>\n            <div *ngSwitchCase=\"'ReceiveTask'\">\n                <diagram-receive-task [data]=\"element\"></diagram-receive-task>\n            </div>\n            <div *ngSwitchCase=\"'ScriptTask'\">\n                <diagram-script-task [data]=\"element\"></diagram-script-task>\n            </div>\n            <div *ngSwitchCase=\"'BusinessRuleTask'\">\n                <diagram-business-rule-task [data]=\"element\"></diagram-business-rule-task>\n            </div>\n            <div *ngSwitchCase=\"'BoundaryEvent'\">\n                <diagram-boundary-event [data]=\"element\"></diagram-boundary-event>\n            </div>\n            <div *ngSwitchCase=\"'ThrowEvent'\">\n                <diagram-throw-event [data]=\"element\"></diagram-throw-event>\n            </div>\n            <div *ngSwitchCase=\"'IntermediateCatchEvent'\">\n                <diagram-intermediate-catching-event [data]=\"element\"></diagram-intermediate-catching-event>\n            </div>\n            <div *ngSwitchCase=\"'SubProcess'\">\n                <diagram-subprocess [data]=\"element\"></diagram-subprocess>\n            </div>\n            <div *ngSwitchCase=\"'EventSubProcess'\">\n                <diagram-event-subprocess [data]=\"element\"></diagram-event-subprocess>\n            </div>\n        </div>\n    </div>\n    <div *ngFor=\"let flow of diagram.flows\">\n        <div [ngSwitch]=\"flow.type\">\n            <div *ngSwitchCase=\"'sequenceFlow'\">\n                <adf-diagram-sequence-flow [flow]=\"flow\"></adf-diagram-sequence-flow>\n            </div>\n        </div>\n    </div>\n    <div *ngIf=\"diagram.pools\">\n        <diagram-pools [pools]=\"diagram.pools\"></diagram-pools>\n    </div>\n</div>\n",
                    styles: [".diagram{border:1px solid #d3d3d3;overflow:auto}"]
                }] }
    ];
    /** @nocollapse */
    DiagramComponent.ctorParameters = function () { return [
        { type: DiagramColorService },
        { type: RaphaelService },
        { type: DiagramsService }
    ]; };
    DiagramComponent.propDecorators = {
        processDefinitionId: [{ type: Input }],
        processInstanceId: [{ type: Input }],
        metricPercentages: [{ type: Input }],
        metricColor: [{ type: Input }],
        metricType: [{ type: Input }],
        width: [{ type: Input }],
        height: [{ type: Input }],
        success: [{ type: Output }],
        error: [{ type: Output }]
    };
    return DiagramComponent;
}());
export { DiagramComponent };
if (false) {
    /** @type {?} */
    DiagramComponent.prototype.processDefinitionId;
    /** @type {?} */
    DiagramComponent.prototype.processInstanceId;
    /** @type {?} */
    DiagramComponent.prototype.metricPercentages;
    /** @type {?} */
    DiagramComponent.prototype.metricColor;
    /** @type {?} */
    DiagramComponent.prototype.metricType;
    /** @type {?} */
    DiagramComponent.prototype.width;
    /** @type {?} */
    DiagramComponent.prototype.height;
    /** @type {?} */
    DiagramComponent.prototype.success;
    /** @type {?} */
    DiagramComponent.prototype.error;
    /** @type {?} */
    DiagramComponent.prototype.PADDING_WIDTH;
    /** @type {?} */
    DiagramComponent.prototype.PADDING_HEIGHT;
    /** @type {?} */
    DiagramComponent.prototype.diagram;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype.diagramColorService;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype.raphaelService;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype.diagramsService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhZ3JhbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWluc2lnaHRzLyIsInNvdXJjZXMiOlsiZGlhZ3JhbS9jb21wb25lbnRzL2RpYWdyYW0uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBYSxNQUFNLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBRWpHLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUMvRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDL0QsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRTNEO0lBc0NJLDBCQUFvQixtQkFBd0MsRUFDeEMsY0FBOEIsRUFDOUIsZUFBZ0M7UUFGaEMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQUN4QyxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBckJwRCxlQUFVLEdBQVcsRUFBRSxDQUFDO1FBR3hCLFVBQUssR0FBVyxJQUFJLENBQUM7UUFHckIsV0FBTSxHQUFXLEdBQUcsQ0FBQztRQUdyQixZQUFPLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUc3QixVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUUzQixrQkFBYSxHQUFXLEVBQUUsQ0FBQztRQUMzQixtQkFBYyxHQUFXLEVBQUUsQ0FBQztJQU81QixDQUFDOzs7OztJQUVELHNDQUFXOzs7O0lBQVgsVUFBWSxPQUFzQjtRQUM5QixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsbUJBQW1CLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxXQUFX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LEVBQUUsQ0FBQztJQUNoQyxDQUFDOztnQkFsR0osU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxhQUFhO29CQUV2QixzdEdBQXVDOztpQkFDMUM7Ozs7Z0JBUlEsbUJBQW1CO2dCQUVuQixjQUFjO2dCQURkLGVBQWU7OztzQ0FTbkIsS0FBSztvQ0FHTCxLQUFLO29DQUdMLEtBQUs7OEJBR0wsS0FBSzs2QkFHTCxLQUFLO3dCQUdMLEtBQUs7eUJBR0wsS0FBSzswQkFHTCxNQUFNO3dCQUdOLE1BQU07O0lBcUVYLHVCQUFDO0NBQUEsQUFuR0QsSUFtR0M7U0E5RlksZ0JBQWdCOzs7SUFDekIsK0NBQ3lCOztJQUV6Qiw2Q0FDdUI7O0lBRXZCLDZDQUN1Qjs7SUFFdkIsdUNBQ2lCOztJQUVqQixzQ0FDd0I7O0lBRXhCLGlDQUNxQjs7SUFFckIsa0NBQ3FCOztJQUVyQixtQ0FDNkI7O0lBRTdCLGlDQUMyQjs7SUFFM0IseUNBQTJCOztJQUMzQiwwQ0FBNEI7O0lBRTVCLG1DQUFzQjs7Ozs7SUFFViwrQ0FBZ0Q7Ozs7O0lBQ2hELDBDQUFzQzs7Ozs7SUFDdEMsMkNBQXdDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE91dHB1dCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGlhZ3JhbUVsZW1lbnRNb2RlbCB9IGZyb20gJy4uL21vZGVscy9kaWFncmFtL2RpYWdyYW1FbGVtZW50Lm1vZGVsJztcbmltcG9ydCB7IERpYWdyYW1Nb2RlbCB9IGZyb20gJy4uL21vZGVscy9kaWFncmFtL2RpYWdyYW0ubW9kZWwnO1xuaW1wb3J0IHsgRGlhZ3JhbUNvbG9yU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2RpYWdyYW0tY29sb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBEaWFncmFtc1NlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9kaWFncmFtcy5zZXJ2aWNlJztcbmltcG9ydCB7IFJhcGhhZWxTZXJ2aWNlIH0gZnJvbSAnLi9yYXBoYWVsL3JhcGhhZWwuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWRpYWdyYW0nLFxuICAgIHN0eWxlVXJsczogWycuL2RpYWdyYW0uY29tcG9uZW50LmNzcyddLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9kaWFncmFtLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBEaWFncmFtQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgICBASW5wdXQoKVxuICAgIHByb2Nlc3NEZWZpbml0aW9uSWQ6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgcHJvY2Vzc0luc3RhbmNlSWQ6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgbWV0cmljUGVyY2VudGFnZXM6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgbWV0cmljQ29sb3I6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgbWV0cmljVHlwZTogc3RyaW5nID0gJyc7XG5cbiAgICBASW5wdXQoKVxuICAgIHdpZHRoOiBudW1iZXIgPSAxMDAwO1xuXG4gICAgQElucHV0KClcbiAgICBoZWlnaHQ6IG51bWJlciA9IDUwMDtcblxuICAgIEBPdXRwdXQoKVxuICAgIHN1Y2Nlc3MgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBlcnJvciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIFBBRERJTkdfV0lEVEg6IG51bWJlciA9IDYwO1xuICAgIFBBRERJTkdfSEVJR0hUOiBudW1iZXIgPSA2MDtcblxuICAgIGRpYWdyYW06IERpYWdyYW1Nb2RlbDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGlhZ3JhbUNvbG9yU2VydmljZTogRGlhZ3JhbUNvbG9yU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHJhcGhhZWxTZXJ2aWNlOiBSYXBoYWVsU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRpYWdyYW1zU2VydmljZTogRGlhZ3JhbXNTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZGlhZ3JhbUNvbG9yU2VydmljZS5zZXRUb3RhbENvbG9ycyh0aGlzLm1ldHJpY0NvbG9yKTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0RlZmluaXRpb25JZCkge1xuICAgICAgICAgICAgdGhpcy5nZXRQcm9jZXNzRGVmaW5pdGlvbk1vZGVsKHRoaXMucHJvY2Vzc0RlZmluaXRpb25JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdldFJ1bm5pbmdQcm9jZXNzRGVmaW5pdGlvbk1vZGVsKHRoaXMucHJvY2Vzc0luc3RhbmNlSWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UnVubmluZ1Byb2Nlc3NEZWZpbml0aW9uTW9kZWwocHJvY2Vzc0luc3RhbmNlSWQ6IHN0cmluZykge1xuICAgICAgICB0aGlzLmRpYWdyYW1zU2VydmljZS5nZXRSdW5uaW5nUHJvY2Vzc0RlZmluaXRpb25Nb2RlbChwcm9jZXNzSW5zdGFuY2VJZCkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgKHJlczogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFncmFtID0gbmV3IERpYWdyYW1Nb2RlbChyZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmFwaGFlbFNlcnZpY2Uuc2V0dGluZyh0aGlzLmRpYWdyYW0uZGlhZ3JhbVdpZHRoICsgdGhpcy5QQURESU5HX1dJRFRILFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpYWdyYW0uZGlhZ3JhbUhlaWdodCArIHRoaXMuUEFERElOR19IRUlHSFQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWV0cmljVmFsdWVUb0RpYWdyYW1FbGVtZW50KHRoaXMuZGlhZ3JhbSwgdGhpcy5tZXRyaWNQZXJjZW50YWdlcywgdGhpcy5tZXRyaWNUeXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MuZW1pdChyZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldFByb2Nlc3NEZWZpbml0aW9uTW9kZWwocHJvY2Vzc0RlZmluaXRpb25JZDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuZGlhZ3JhbXNTZXJ2aWNlLmdldFByb2Nlc3NEZWZpbml0aW9uTW9kZWwocHJvY2Vzc0RlZmluaXRpb25JZCkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgKHJlczogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFncmFtID0gbmV3IERpYWdyYW1Nb2RlbChyZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmFwaGFlbFNlcnZpY2Uuc2V0dGluZyh0aGlzLmRpYWdyYW0uZGlhZ3JhbVdpZHRoICsgdGhpcy5QQURESU5HX1dJRFRILFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpYWdyYW0uZGlhZ3JhbUhlaWdodCArIHRoaXMuUEFERElOR19IRUlHSFQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWV0cmljVmFsdWVUb0RpYWdyYW1FbGVtZW50KHRoaXMuZGlhZ3JhbSwgdGhpcy5tZXRyaWNQZXJjZW50YWdlcywgdGhpcy5tZXRyaWNUeXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MuZW1pdChyZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldE1ldHJpY1ZhbHVlVG9EaWFncmFtRWxlbWVudChkaWFncmFtOiBEaWFncmFtTW9kZWwsIG1ldHJpY3M6IGFueSwgbWV0cmljVHlwZTogc3RyaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBtZXRyaWNzKSB7XG4gICAgICAgICAgICBpZiAobWV0cmljcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kRWxlbWVudDogRGlhZ3JhbUVsZW1lbnRNb2RlbCA9IGRpYWdyYW0uZWxlbWVudHMuZmluZChcbiAgICAgICAgICAgICAgICAgICAgKGVsZW1lbnQ6IERpYWdyYW1FbGVtZW50TW9kZWwpID0+IGVsZW1lbnQuaWQgPT09IGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEVsZW1lbnQudmFsdWUgPSBtZXRyaWNzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRWxlbWVudC5kYXRhVHlwZSA9IG1ldHJpY1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmFwaGFlbFNlcnZpY2UucmVzZXQoKTtcbiAgICB9XG59XG4iXX0=