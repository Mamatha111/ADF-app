/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { DiagramModel } from '../models/diagram/diagram.model';
import { DiagramColorService } from '../services/diagram-color.service';
import { DiagramsService } from '../services/diagrams.service';
import { RaphaelService } from './raphael/raphael.service';
export class DiagramComponent {
    /**
     * @param {?} diagramColorService
     * @param {?} raphaelService
     * @param {?} diagramsService
     */
    constructor(diagramColorService, raphaelService, diagramsService) {
        this.diagramColorService = diagramColorService;
        this.raphaelService = raphaelService;
        this.diagramsService = diagramsService;
        this.metricType = '';
        this.width = 1000;
        this.height = 500;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.PADDING_WIDTH = 60;
        this.PADDING_HEIGHT = 60;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.reset();
        this.diagramColorService.setTotalColors(this.metricColor);
        if (this.processDefinitionId) {
            this.getProcessDefinitionModel(this.processDefinitionId);
        }
        else {
            this.getRunningProcessDefinitionModel(this.processInstanceId);
        }
    }
    /**
     * @param {?} processInstanceId
     * @return {?}
     */
    getRunningProcessDefinitionModel(processInstanceId) {
        this.diagramsService.getRunningProcessDefinitionModel(processInstanceId).subscribe((res) => {
            this.diagram = new DiagramModel(res);
            this.raphaelService.setting(this.diagram.diagramWidth + this.PADDING_WIDTH, this.diagram.diagramHeight + this.PADDING_HEIGHT);
            this.setMetricValueToDiagramElement(this.diagram, this.metricPercentages, this.metricType);
            this.success.emit(res);
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @param {?} processDefinitionId
     * @return {?}
     */
    getProcessDefinitionModel(processDefinitionId) {
        this.diagramsService.getProcessDefinitionModel(processDefinitionId).subscribe((res) => {
            this.diagram = new DiagramModel(res);
            this.raphaelService.setting(this.diagram.diagramWidth + this.PADDING_WIDTH, this.diagram.diagramHeight + this.PADDING_HEIGHT);
            this.setMetricValueToDiagramElement(this.diagram, this.metricPercentages, this.metricType);
            this.success.emit(res);
        }, (err) => {
            this.error.emit(err);
        });
    }
    /**
     * @param {?} diagram
     * @param {?} metrics
     * @param {?} metricType
     * @return {?}
     */
    setMetricValueToDiagramElement(diagram, metrics, metricType) {
        for (let key in metrics) {
            if (metrics.hasOwnProperty(key)) {
                /** @type {?} */
                let foundElement = diagram.elements.find((element) => element.id === key);
                if (foundElement) {
                    foundElement.value = metrics[key];
                    foundElement.dataType = metricType;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.raphaelService.reset();
    }
}
DiagramComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-diagram',
                template: "<div *ngIf=\"diagram\" class=\"diagram\">\n    <div *ngFor=\"let element of diagram.elements\">\n        <div [ngSwitch]=\"element.type\">\n            <div *ngSwitchCase=\"'StartEvent'\">\n                <diagram-start-event [data]=\"element\"></diagram-start-event>\n            </div>\n            <div *ngSwitchCase=\"'ExclusiveGateway'\">\n                <diagram-exclusive-gateway [data]=\"element\"></diagram-exclusive-gateway>\n            </div>\n            <div *ngSwitchCase=\"'InclusiveGateway'\">\n                <diagram-inclusive-gateway [data]=\"element\"></diagram-inclusive-gateway>\n            </div>\n            <div *ngSwitchCase=\"'EventGateway'\">\n                <diagram-event-gateway [data]=\"element\"></diagram-event-gateway>\n            </div>\n            <div *ngSwitchCase=\"'ParallelGateway'\">\n                <diagram-parallel-gateway [data]=\"element\"></diagram-parallel-gateway>\n            </div>\n            <div *ngSwitchCase=\"'EndEvent'\">\n                <diagram-end-event [data]=\"element\"></diagram-end-event>\n            </div>\n            <div *ngSwitchCase=\"'UserTask'\">\n                <diagram-user-task [data]=\"element\"></diagram-user-task>\n            </div>\n            <div *ngSwitchCase=\"'ManualTask'\">\n                <diagram-manual-task [data]=\"element\"></diagram-manual-task>\n            </div>\n            <div *ngSwitchCase=\"'ServiceTask'\">\n                <diagram-container-service-task [data]=\"element\"></diagram-container-service-task>\n            </div>\n            <div *ngSwitchCase=\"'ReceiveTask'\">\n                <diagram-receive-task [data]=\"element\"></diagram-receive-task>\n            </div>\n            <div *ngSwitchCase=\"'ScriptTask'\">\n                <diagram-script-task [data]=\"element\"></diagram-script-task>\n            </div>\n            <div *ngSwitchCase=\"'BusinessRuleTask'\">\n                <diagram-business-rule-task [data]=\"element\"></diagram-business-rule-task>\n            </div>\n            <div *ngSwitchCase=\"'BoundaryEvent'\">\n                <diagram-boundary-event [data]=\"element\"></diagram-boundary-event>\n            </div>\n            <div *ngSwitchCase=\"'ThrowEvent'\">\n                <diagram-throw-event [data]=\"element\"></diagram-throw-event>\n            </div>\n            <div *ngSwitchCase=\"'IntermediateCatchEvent'\">\n                <diagram-intermediate-catching-event [data]=\"element\"></diagram-intermediate-catching-event>\n            </div>\n            <div *ngSwitchCase=\"'SubProcess'\">\n                <diagram-subprocess [data]=\"element\"></diagram-subprocess>\n            </div>\n            <div *ngSwitchCase=\"'EventSubProcess'\">\n                <diagram-event-subprocess [data]=\"element\"></diagram-event-subprocess>\n            </div>\n        </div>\n    </div>\n    <div *ngFor=\"let flow of diagram.flows\">\n        <div [ngSwitch]=\"flow.type\">\n            <div *ngSwitchCase=\"'sequenceFlow'\">\n                <adf-diagram-sequence-flow [flow]=\"flow\"></adf-diagram-sequence-flow>\n            </div>\n        </div>\n    </div>\n    <div *ngIf=\"diagram.pools\">\n        <diagram-pools [pools]=\"diagram.pools\"></diagram-pools>\n    </div>\n</div>\n",
                styles: [".diagram{border:1px solid #d3d3d3;overflow:auto}"]
            }] }
];
/** @nocollapse */
DiagramComponent.ctorParameters = () => [
    { type: DiagramColorService },
    { type: RaphaelService },
    { type: DiagramsService }
];
DiagramComponent.propDecorators = {
    processDefinitionId: [{ type: Input }],
    processInstanceId: [{ type: Input }],
    metricPercentages: [{ type: Input }],
    metricColor: [{ type: Input }],
    metricType: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    DiagramComponent.prototype.processDefinitionId;
    /** @type {?} */
    DiagramComponent.prototype.processInstanceId;
    /** @type {?} */
    DiagramComponent.prototype.metricPercentages;
    /** @type {?} */
    DiagramComponent.prototype.metricColor;
    /** @type {?} */
    DiagramComponent.prototype.metricType;
    /** @type {?} */
    DiagramComponent.prototype.width;
    /** @type {?} */
    DiagramComponent.prototype.height;
    /** @type {?} */
    DiagramComponent.prototype.success;
    /** @type {?} */
    DiagramComponent.prototype.error;
    /** @type {?} */
    DiagramComponent.prototype.PADDING_WIDTH;
    /** @type {?} */
    DiagramComponent.prototype.PADDING_HEIGHT;
    /** @type {?} */
    DiagramComponent.prototype.diagram;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype.diagramColorService;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype.raphaelService;
    /**
     * @type {?}
     * @private
     */
    DiagramComponent.prototype.diagramsService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhZ3JhbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWluc2lnaHRzLyIsInNvdXJjZXMiOlsiZGlhZ3JhbS9jb21wb25lbnRzL2RpYWdyYW0uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBYSxNQUFNLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBRWpHLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUMvRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDL0QsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBTzNELE1BQU0sT0FBTyxnQkFBZ0I7Ozs7OztJQWlDekIsWUFBb0IsbUJBQXdDLEVBQ3hDLGNBQThCLEVBQzlCLGVBQWdDO1FBRmhDLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFDeEMsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLG9CQUFlLEdBQWYsZUFBZSxDQUFpQjtRQXJCcEQsZUFBVSxHQUFXLEVBQUUsQ0FBQztRQUd4QixVQUFLLEdBQVcsSUFBSSxDQUFDO1FBR3JCLFdBQU0sR0FBVyxHQUFHLENBQUM7UUFHckIsWUFBTyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFHN0IsVUFBSyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFFM0Isa0JBQWEsR0FBVyxFQUFFLENBQUM7UUFDM0IsbUJBQWMsR0FBVyxFQUFFLENBQUM7SUFPNUIsQ0FBQzs7Ozs7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDOUIsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxJ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QUNQLFFBQVEsRUFBRSxhQUFhO2dCQUV2QixzdEdBQXVDOzthQUMxQzs7OztZQVJRLG1CQUFtQjtZQUVuQixjQUFjO1lBRGQsZUFBZTs7O2tDQVNuQixLQUFLO2dDQUdMLEtBQUs7Z0NBR0wsS0FBSzswQkFHTCxLQUFLO3lCQUdMLEtBQUs7b0JBR0wsS0FBSztxQkFHTCxLQUFLO3NCQUdMLE1BQU07b0JBR04sTUFBTTs7OztJQXhCUCwrQ0FDeUI7O0lBRXpCLDZDQUN1Qjs7SUFFdkIsNkNBQ3VCOztJQUV2Qix1Q0FDaUI7O0lBRWpCLHNDQUN3Qjs7SUFFeEIsaUNBQ3FCOztJQUVyQixrQ0FDcUI7O0lBRXJCLG1DQUM2Qjs7SUFFN0IsaUNBQzJCOztJQUUzQix5Q0FBMkI7O0lBQzNCLDBDQUE0Qjs7SUFFNUIsbUNBQXNCOzs7OztJQUVWLCtDQUFnRDs7Ozs7SUFDaEQsMENBQXNDOzs7OztJQUN0QywyQ0FBd0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEaWFncmFtRWxlbWVudE1vZGVsIH0gZnJvbSAnLi4vbW9kZWxzL2RpYWdyYW0vZGlhZ3JhbUVsZW1lbnQubW9kZWwnO1xuaW1wb3J0IHsgRGlhZ3JhbU1vZGVsIH0gZnJvbSAnLi4vbW9kZWxzL2RpYWdyYW0vZGlhZ3JhbS5tb2RlbCc7XG5pbXBvcnQgeyBEaWFncmFtQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvZGlhZ3JhbS1jb2xvci5zZXJ2aWNlJztcbmltcG9ydCB7IERpYWdyYW1zU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2RpYWdyYW1zLnNlcnZpY2UnO1xuaW1wb3J0IHsgUmFwaGFlbFNlcnZpY2UgfSBmcm9tICcuL3JhcGhhZWwvcmFwaGFlbC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtZGlhZ3JhbScsXG4gICAgc3R5bGVVcmxzOiBbJy4vZGlhZ3JhbS5jb21wb25lbnQuY3NzJ10sXG4gICAgdGVtcGxhdGVVcmw6ICcuL2RpYWdyYW0uY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIERpYWdyYW1Db21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICAgIEBJbnB1dCgpXG4gICAgcHJvY2Vzc0RlZmluaXRpb25JZDogYW55O1xuXG4gICAgQElucHV0KClcbiAgICBwcm9jZXNzSW5zdGFuY2VJZDogYW55O1xuXG4gICAgQElucHV0KClcbiAgICBtZXRyaWNQZXJjZW50YWdlczogYW55O1xuXG4gICAgQElucHV0KClcbiAgICBtZXRyaWNDb2xvcjogYW55O1xuXG4gICAgQElucHV0KClcbiAgICBtZXRyaWNUeXBlOiBzdHJpbmcgPSAnJztcblxuICAgIEBJbnB1dCgpXG4gICAgd2lkdGg6IG51bWJlciA9IDEwMDA7XG5cbiAgICBASW5wdXQoKVxuICAgIGhlaWdodDogbnVtYmVyID0gNTAwO1xuXG4gICAgQE91dHB1dCgpXG4gICAgc3VjY2VzcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIGVycm9yID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgUEFERElOR19XSURUSDogbnVtYmVyID0gNjA7XG4gICAgUEFERElOR19IRUlHSFQ6IG51bWJlciA9IDYwO1xuXG4gICAgZGlhZ3JhbTogRGlhZ3JhbU1vZGVsO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkaWFncmFtQ29sb3JTZXJ2aWNlOiBEaWFncmFtQ29sb3JTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgcmFwaGFlbFNlcnZpY2U6IFJhcGhhZWxTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZGlhZ3JhbXNTZXJ2aWNlOiBEaWFncmFtc1NlcnZpY2UpIHtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5kaWFncmFtQ29sb3JTZXJ2aWNlLnNldFRvdGFsQ29sb3JzKHRoaXMubWV0cmljQ29sb3IpO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzRGVmaW5pdGlvbklkKSB7XG4gICAgICAgICAgICB0aGlzLmdldFByb2Nlc3NEZWZpbml0aW9uTW9kZWwodGhpcy5wcm9jZXNzRGVmaW5pdGlvbklkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UnVubmluZ1Byb2Nlc3NEZWZpbml0aW9uTW9kZWwodGhpcy5wcm9jZXNzSW5zdGFuY2VJZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRSdW5uaW5nUHJvY2Vzc0RlZmluaXRpb25Nb2RlbChwcm9jZXNzSW5zdGFuY2VJZDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuZGlhZ3JhbXNTZXJ2aWNlLmdldFJ1bm5pbmdQcm9jZXNzRGVmaW5pdGlvbk1vZGVsKHByb2Nlc3NJbnN0YW5jZUlkKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAocmVzOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdyYW0gPSBuZXcgRGlhZ3JhbU1vZGVsKHJlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yYXBoYWVsU2VydmljZS5zZXR0aW5nKHRoaXMuZGlhZ3JhbS5kaWFncmFtV2lkdGggKyB0aGlzLlBBRERJTkdfV0lEVEgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlhZ3JhbS5kaWFncmFtSGVpZ2h0ICsgdGhpcy5QQURESU5HX0hFSUdIVCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNZXRyaWNWYWx1ZVRvRGlhZ3JhbUVsZW1lbnQodGhpcy5kaWFncmFtLCB0aGlzLm1ldHJpY1BlcmNlbnRhZ2VzLCB0aGlzLm1ldHJpY1R5cGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VjY2Vzcy5lbWl0KHJlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycjogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvci5lbWl0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0UHJvY2Vzc0RlZmluaXRpb25Nb2RlbChwcm9jZXNzRGVmaW5pdGlvbklkOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5kaWFncmFtc1NlcnZpY2UuZ2V0UHJvY2Vzc0RlZmluaXRpb25Nb2RlbChwcm9jZXNzRGVmaW5pdGlvbklkKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAocmVzOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdyYW0gPSBuZXcgRGlhZ3JhbU1vZGVsKHJlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yYXBoYWVsU2VydmljZS5zZXR0aW5nKHRoaXMuZGlhZ3JhbS5kaWFncmFtV2lkdGggKyB0aGlzLlBBRERJTkdfV0lEVEgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlhZ3JhbS5kaWFncmFtSGVpZ2h0ICsgdGhpcy5QQURESU5HX0hFSUdIVCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNZXRyaWNWYWx1ZVRvRGlhZ3JhbUVsZW1lbnQodGhpcy5kaWFncmFtLCB0aGlzLm1ldHJpY1BlcmNlbnRhZ2VzLCB0aGlzLm1ldHJpY1R5cGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VjY2Vzcy5lbWl0KHJlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycjogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvci5lbWl0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2V0TWV0cmljVmFsdWVUb0RpYWdyYW1FbGVtZW50KGRpYWdyYW06IERpYWdyYW1Nb2RlbCwgbWV0cmljczogYW55LCBtZXRyaWNUeXBlOiBzdHJpbmcpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG1ldHJpY3MpIHtcbiAgICAgICAgICAgIGlmIChtZXRyaWNzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmRFbGVtZW50OiBEaWFncmFtRWxlbWVudE1vZGVsID0gZGlhZ3JhbS5lbGVtZW50cy5maW5kKFxuICAgICAgICAgICAgICAgICAgICAoZWxlbWVudDogRGlhZ3JhbUVsZW1lbnRNb2RlbCkgPT4gZWxlbWVudC5pZCA9PT0ga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRWxlbWVudC52YWx1ZSA9IG1ldHJpY3Nba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRFbGVtZW50LmRhdGFUeXBlID0gbWV0cmljVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5yYXBoYWVsU2VydmljZS5yZXNldCgpO1xuICAgIH1cbn1cbiJdfQ==