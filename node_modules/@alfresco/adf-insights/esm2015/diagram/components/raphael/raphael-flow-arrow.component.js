/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Directive, ElementRef, EventEmitter, Input, Output } from '@angular/core';
import { Polyline } from './polyline';
import { RaphaelBase } from './raphael-base';
import { RaphaelService } from './raphael.service';
/**
 * Directive selectors without adf- prefix will be deprecated on 3.0.0
 */
export class RaphaelFlowArrowDirective extends RaphaelBase {
    /**
     * @param {?} elementRef
     * @param {?} raphaelService
     */
    constructor(elementRef, raphaelService) {
        super(elementRef, raphaelService);
        this.elementRef = elementRef;
        this.error = new EventEmitter();
        this.ARROW_WIDTH = 4;
        this.SEQUENCE_FLOW_STROKE = 1.5;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.draw(this.flow);
    }
    /**
     * @param {?} flow
     * @return {?}
     */
    draw(flow) {
        /** @type {?} */
        let line = this.drawLine(flow);
        this.drawArrow(line);
    }
    /**
     * @param {?} flow
     * @return {?}
     */
    drawLine(flow) {
        /** @type {?} */
        let polyline = new Polyline(flow.id, flow.waypoints, this.SEQUENCE_FLOW_STROKE, this.paper);
        polyline.element = this.paper.path(polyline.path);
        polyline.element.attr({ 'stroke-width': this.SEQUENCE_FLOW_STROKE });
        polyline.element.attr({ 'stroke': '#585858' });
        polyline.element.node.id = this.flow.id;
        /** @type {?} */
        let lastLineIndex = polyline.getLinesCount() - 1;
        /** @type {?} */
        let line = polyline.getLine(lastLineIndex);
        return line;
    }
    /**
     * @param {?} line
     * @return {?}
     */
    drawArrow(line) {
        /** @type {?} */
        let doubleArrowWidth = 2 * this.ARROW_WIDTH;
        /** @type {?} */
        let width = this.ARROW_WIDTH / 2 + .5;
        /** @type {?} */
        let arrowHead = this.paper.path('M0 0L-' + width + '-' + doubleArrowWidth + 'L' + width + ' -' + doubleArrowWidth + 'z');
        arrowHead.transform('t' + line.x2 + ',' + line.y2);
        /** @type {?} */
        let angle = Raphael.deg(line.angle - Math.PI / 2);
        arrowHead.transform('...r' + angle + ' 0 0');
        arrowHead.attr('fill', '#585858');
        arrowHead.attr('stroke-width', this.SEQUENCE_FLOW_STROKE);
        arrowHead.attr('stroke', '#585858');
    }
}
RaphaelFlowArrowDirective.decorators = [
    { type: Directive, args: [{ selector: 'adf-raphael-flow-arrow, raphael-flow-arrow' },] }
];
/** @nocollapse */
RaphaelFlowArrowDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: RaphaelService }
];
RaphaelFlowArrowDirective.propDecorators = {
    paper: [{ type: Input }],
    flow: [{ type: Input }],
    error: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.paper;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.flow;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.error;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.ARROW_WIDTH;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.SEQUENCE_FLOW_STROKE;
    /** @type {?} */
    RaphaelFlowArrowDirective.prototype.elementRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFwaGFlbC1mbG93LWFycm93LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtaW5zaWdodHMvIiwic291cmNlcyI6WyJkaWFncmFtL2NvbXBvbmVudHMvcmFwaGFlbC9yYXBoYWVsLWZsb3ctYXJyb3cuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQVUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNGLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDdEMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQzs7OztBQVFuRCxNQUFNLE9BQU8seUJBQTBCLFNBQVEsV0FBVzs7Ozs7SUFhdEQsWUFBbUIsVUFBc0IsRUFDN0IsY0FBOEI7UUFDdEMsS0FBSyxDQUFDLFVBQVUsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUZuQixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBTHpDLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBRTNCLGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLHlCQUFvQixHQUFHLEdBQUcsQ0FBQztJQUszQixDQUFDOzs7O0lBRUQsUUFBUTtRQUVKLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3pCLENBQUM7Ozs7O0lBRU0sSUFBSSxDQUFDLElBQVM7O1lBQ2IsSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO1FBQzlCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekIsQ0FBQzs7Ozs7SUFFTSxRQUFRLENBQUMsSUFBUzs7WUFDakIsUUFBUSxHQUFHLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUMzRixRQUFRLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsRCxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsb0JBQW9CLEVBQUMsQ0FBQyxDQUFDO1FBQ25FLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUMsUUFBUSxFQUFFLFNBQVMsRUFBQyxDQUFDLENBQUM7UUFFN0MsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDOztZQUVwQyxhQUFhLEdBQUcsUUFBUSxDQUFDLGFBQWEsRUFBRSxHQUFHLENBQUM7O1lBQzVDLElBQUksR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztRQUMxQyxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDOzs7OztJQUVNLFNBQVMsQ0FBQyxJQUFTOztZQUNsQixnQkFBZ0IsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVc7O1lBQ3ZDLEtBQUssR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsR0FBRyxFQUFFOztZQUNqQyxTQUFTLEdBQVEsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsZ0JBQWdCLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxJQUFJLEdBQUcsZ0JBQWdCLEdBQUcsR0FBRyxDQUFDO1FBRTdILFNBQVMsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQzs7WUFDL0MsS0FBSyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNqRCxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUM7UUFFN0MsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFFbEMsU0FBUyxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDMUQsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFFeEMsQ0FBQzs7O1lBeERKLFNBQVMsU0FBQyxFQUFDLFFBQVEsRUFBRSw0Q0FBNEMsRUFBQzs7OztZQVYvQyxVQUFVO1lBR3JCLGNBQWM7OztvQkFTbEIsS0FBSzttQkFHTCxLQUFLO29CQUdMLE1BQU07Ozs7SUFOUCwwQ0FDVzs7SUFFWCx5Q0FDVTs7SUFFViwwQ0FDMkI7O0lBRTNCLGdEQUFnQjs7SUFDaEIseURBQTJCOztJQUVmLCtDQUE2QiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi9wb2x5bGluZSc7XG5pbXBvcnQgeyBSYXBoYWVsQmFzZSB9IGZyb20gJy4vcmFwaGFlbC1iYXNlJztcbmltcG9ydCB7IFJhcGhhZWxTZXJ2aWNlIH0gZnJvbSAnLi9yYXBoYWVsLnNlcnZpY2UnO1xuXG5kZWNsYXJlIGxldCBSYXBoYWVsOiBhbnk7XG5cbi8qKlxuICogRGlyZWN0aXZlIHNlbGVjdG9ycyB3aXRob3V0IGFkZi0gcHJlZml4IHdpbGwgYmUgZGVwcmVjYXRlZCBvbiAzLjAuMFxuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ2FkZi1yYXBoYWVsLWZsb3ctYXJyb3csIHJhcGhhZWwtZmxvdy1hcnJvdyd9KVxuZXhwb3J0IGNsYXNzIFJhcGhhZWxGbG93QXJyb3dEaXJlY3RpdmUgZXh0ZW5kcyBSYXBoYWVsQmFzZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgQElucHV0KClcbiAgICBwYXBlcjogYW55O1xuXG4gICAgQElucHV0KClcbiAgICBmbG93OiBhbnk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBlcnJvciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIEFSUk9XX1dJRFRIID0gNDtcbiAgICBTRVFVRU5DRV9GTE9XX1NUUk9LRSA9IDEuNTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgIHJhcGhhZWxTZXJ2aWNlOiBSYXBoYWVsU2VydmljZSkge1xuICAgICAgICBzdXBlcihlbGVtZW50UmVmLCByYXBoYWVsU2VydmljZSk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG5cbiAgICAgICAgdGhpcy5kcmF3KHRoaXMuZmxvdyk7XG4gICAgfVxuXG4gICAgcHVibGljIGRyYXcoZmxvdzogYW55KSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5kcmF3TGluZShmbG93KTtcbiAgICAgICAgdGhpcy5kcmF3QXJyb3cobGluZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGRyYXdMaW5lKGZsb3c6IGFueSkge1xuICAgICAgICBsZXQgcG9seWxpbmUgPSBuZXcgUG9seWxpbmUoZmxvdy5pZCwgZmxvdy53YXlwb2ludHMsIHRoaXMuU0VRVUVOQ0VfRkxPV19TVFJPS0UsIHRoaXMucGFwZXIpO1xuICAgICAgICBwb2x5bGluZS5lbGVtZW50ID0gdGhpcy5wYXBlci5wYXRoKHBvbHlsaW5lLnBhdGgpO1xuICAgICAgICBwb2x5bGluZS5lbGVtZW50LmF0dHIoeydzdHJva2Utd2lkdGgnOiB0aGlzLlNFUVVFTkNFX0ZMT1dfU1RST0tFfSk7XG4gICAgICAgIHBvbHlsaW5lLmVsZW1lbnQuYXR0cih7J3N0cm9rZSc6ICcjNTg1ODU4J30pO1xuXG4gICAgICAgIHBvbHlsaW5lLmVsZW1lbnQubm9kZS5pZCA9IHRoaXMuZmxvdy5pZDtcblxuICAgICAgICBsZXQgbGFzdExpbmVJbmRleCA9IHBvbHlsaW5lLmdldExpbmVzQ291bnQoKSAtIDE7XG4gICAgICAgIGxldCBsaW5lID0gcG9seWxpbmUuZ2V0TGluZShsYXN0TGluZUluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgcHVibGljIGRyYXdBcnJvdyhsaW5lOiBhbnkpIHtcbiAgICAgICAgbGV0IGRvdWJsZUFycm93V2lkdGggPSAyICogdGhpcy5BUlJPV19XSURUSDtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5BUlJPV19XSURUSCAvIDIgKyAuNTtcbiAgICAgICAgbGV0IGFycm93SGVhZDogYW55ID0gdGhpcy5wYXBlci5wYXRoKCdNMCAwTC0nICsgd2lkdGggKyAnLScgKyBkb3VibGVBcnJvd1dpZHRoICsgJ0wnICsgd2lkdGggKyAnIC0nICsgZG91YmxlQXJyb3dXaWR0aCArICd6Jyk7XG5cbiAgICAgICAgYXJyb3dIZWFkLnRyYW5zZm9ybSgndCcgKyBsaW5lLngyICsgJywnICsgbGluZS55Mik7XG4gICAgICAgIGxldCBhbmdsZSA9IFJhcGhhZWwuZGVnKGxpbmUuYW5nbGUgLSBNYXRoLlBJIC8gMik7XG4gICAgICAgIGFycm93SGVhZC50cmFuc2Zvcm0oJy4uLnInICsgYW5nbGUgKyAnIDAgMCcpO1xuXG4gICAgICAgIGFycm93SGVhZC5hdHRyKCdmaWxsJywgJyM1ODU4NTgnKTtcblxuICAgICAgICBhcnJvd0hlYWQuYXR0cignc3Ryb2tlLXdpZHRoJywgdGhpcy5TRVFVRU5DRV9GTE9XX1NUUk9LRSk7XG4gICAgICAgIGFycm93SGVhZC5hdHRyKCdzdHJva2UnLCAnIzU4NTg1OCcpO1xuXG4gICAgfVxufVxuIl19