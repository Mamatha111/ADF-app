/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:no-input-rename  */
import { MOMENT_DATE_FORMATS, MomentDateAdapter, UserPreferencesService, UserPreferenceValues } from '@alfresco/adf-core';
import { Component, EventEmitter, Input, Output, ViewEncapsulation } from '@angular/core';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { DateAdapter, MAT_DATE_FORMATS } from '@angular/material';
import moment from 'moment-es6';
const ɵ0 = MOMENT_DATE_FORMATS;
export class DateRangeWidgetComponent {
    /**
     * @param {?} dateAdapter
     * @param {?} userPreferencesService
     */
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.FORMAT_DATE_ACTIVITI = 'YYYY-MM-DD';
        this.SHOW_FORMAT = 'DD/MM/YYYY';
        this.dateRangeChanged = new EventEmitter();
        this.startDatePicker = moment();
        this.endDatePicker = moment();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((locale) => {
            this.dateAdapter.setLocale(locale);
        });
        /** @type {?} */
        let momentDateAdapter = (/** @type {?} */ (this.dateAdapter));
        momentDateAdapter.overrideDisplayFormat = this.SHOW_FORMAT;
        if (this.field) {
            if (this.field.value && this.field.value.startDate) {
                this.startDatePicker = moment(this.field.value.startDate, this.FORMAT_DATE_ACTIVITI);
            }
            if (this.field.value && this.field.value.endDate) {
                this.endDatePicker = moment(this.field.value.endDate, this.FORMAT_DATE_ACTIVITI);
            }
        }
        /** @type {?} */
        let startDateControl = new FormControl(this.startDatePicker);
        startDateControl.setValidators(Validators.required);
        this.dateRange.addControl('startDate', startDateControl);
        /** @type {?} */
        let endDateControl = new FormControl(this.endDatePicker);
        endDateControl.setValidators(Validators.required);
        this.dateRange.addControl('endDate', endDateControl);
        this.dateRange.setValidators(this.dateCheck);
        this.dateRange.valueChanges.subscribe(() => this.onGroupValueChanged());
    }
    /**
     * @return {?}
     */
    onGroupValueChanged() {
        if (this.dateRange.valid) {
            /** @type {?} */
            let dateStart = this.convertToMomentDateWithTime(this.dateRange.controls.startDate.value);
            /** @type {?} */
            let endStart = this.convertToMomentDateWithTime(this.dateRange.controls.endDate.value);
            this.dateRangeChanged.emit({ startDate: dateStart, endDate: endStart });
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    convertToMomentDateWithTime(date) {
        return moment(date, this.FORMAT_DATE_ACTIVITI, true).format(this.FORMAT_DATE_ACTIVITI) + 'T00:00:00.000Z';
    }
    /**
     * @param {?} formControl
     * @return {?}
     */
    dateCheck(formControl) {
        /** @type {?} */
        let startDate = moment(formControl.get('startDate').value);
        /** @type {?} */
        let endDate = moment(formControl.get('endDate').value);
        /** @type {?} */
        let isAfterCheck = startDate.isAfter(endDate);
        return isAfterCheck ? { 'greaterThan': true } : null;
    }
    /**
     * @return {?}
     */
    isStartDateGreaterThanEndDate() {
        return this.dateRange && this.dateRange.errors && this.dateRange.errors.greaterThan;
    }
    /**
     * @return {?}
     */
    isStartDateEmpty() {
        return this.dateRange && this.dateRange.controls.startDate && !this.dateRange.controls.startDate.valid;
    }
}
DateRangeWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-range-widget',
                template: "<label>{{field.nameKey | translate}}</label><br>\n<div [formGroup]=\"dateRange\">\n    <small *ngIf=\"isStartDateGreaterThanEndDate()\" class=\"adf-date-range-analytics-text-danger\">\n       {{'DATE-WIDGET.MESSAGES.START-LESS-THAN-END-DATE' | translate}}\n    </small>\n    <small *ngIf=\"isStartDateEmpty()\" class=\"adf-date-range-analytics-text-danger\">\n       {{'DATE-WIDGET.MESSAGES.START-DATE-REQUIRED' | translate}}\n    </small>\n\n            <mat-grid-list cols=\"2\" rowHeight=\"80px\">\n                <mat-grid-tile>\n                    <mat-form-field>\n                        <input\n                            matInput\n                            [min]=\"minDate\"\n                            [max]=\"maxDate\"\n                            formControlName=\"startDate\"\n                            [matDatepicker]=\"startDate\"\n                            [value]=\"startDatePicker\"\n                            (keydown)=\"true\"\n                            (dateChange)=\"onGroupValueChanged()\"\n                            placeholder=\"{{'DATE-WIDGET.START-DATE' | translate}}\"\n                            id=\"startDate_id\"\n                            required>\n                        <mat-datepicker-toggle matSuffix [for]=\"startDate\" ></mat-datepicker-toggle>\n                    </mat-form-field>\n                    <mat-datepicker\n                        #startDate\n                        [touchUi]=\"true\">\n                    </mat-datepicker>\n                </mat-grid-tile>\n                <mat-grid-tile>\n                    <mat-form-field>\n                        <input\n                            matInput\n                            [min]=\"minDate\"\n                            [max]=\"maxDate\"\n                            formControlName=\"endDate\"\n                            [matDatepicker]=\"endDate\"\n                            [value]=\"endDatePicker\"\n                            (keydown)=\"true\"\n                            (dateChange)=\"onGroupValueChanged()\"\n                            placeholder=\"{{'DATE-WIDGET.END-DATE' | translate}}\"\n                            id=\"endDate_id\"\n                            required>\n                        <mat-datepicker-toggle matSuffix [for]=\"endDate\" ></mat-datepicker-toggle>\n                    </mat-form-field>\n                    <mat-datepicker\n                        #endDate\n                        [touchUi]=\"true\">\n                    </mat-datepicker>\n                </mat-grid-tile>\n            </mat-grid-list>\n</div>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [""]
            }] }
];
/** @nocollapse */
DateRangeWidgetComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];
DateRangeWidgetComponent.propDecorators = {
    dateRange: [{ type: Input, args: ['group',] }],
    field: [{ type: Input }],
    dateRangeChanged: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    DateRangeWidgetComponent.prototype.FORMAT_DATE_ACTIVITI;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.SHOW_FORMAT;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.dateRange;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.field;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.dateRangeChanged;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.minDate;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.maxDate;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.startDatePicker;
    /** @type {?} */
    DateRangeWidgetComponent.prototype.endDatePicker;
    /**
     * @type {?}
     * @private
     */
    DateRangeWidgetComponent.prototype.dateAdapter;
    /**
     * @type {?}
     * @private
     */
    DateRangeWidgetComponent.prototype.userPreferencesService;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS53aWRnZXQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWluc2lnaHRzLyIsInNvdXJjZXMiOlsiYW5hbHl0aWNzLXByb2Nlc3MvY29tcG9uZW50cy93aWRnZXRzL2RhdGUtcmFuZ2UvZGF0ZS1yYW5nZS53aWRnZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRSxzQkFBc0IsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzFILE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBVSxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEcsT0FBTyxFQUFtQixXQUFXLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JGLE9BQU8sRUFBRSxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNsRSxPQUFPLE1BQU0sTUFBTSxZQUFZLENBQUM7V0FRYyxtQkFBbUI7QUFJakUsTUFBTSxPQUFPLHdCQUF3Qjs7Ozs7SUFtQmpDLFlBQ1ksV0FBZ0MsRUFDaEMsc0JBQThDO1FBRDlDLGdCQUFXLEdBQVgsV0FBVyxDQUFxQjtRQUNoQywyQkFBc0IsR0FBdEIsc0JBQXNCLENBQXdCO1FBbkJuRCx5QkFBb0IsR0FBVyxZQUFZLENBQUM7UUFDNUMsZ0JBQVcsR0FBVyxZQUFZLENBQUM7UUFTMUMscUJBQWdCLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFJOUQsb0JBQWUsR0FBVyxNQUFNLEVBQUUsQ0FBQztRQUNuQyxrQkFBYSxHQUFXLE1BQU0sRUFBRSxDQUFDO0lBS2pDLENBQUM7Ozs7SUFFRCxRQUFRO1FBQ0osSUFBSSxDQUFDLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMs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cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1pbnB1dC1yZW5hbWUgICovXG5cbmltcG9ydCB7IE1PTUVOVF9EQVRFX0ZPUk1BVFMsIE1vbWVudERhdGVBZGFwdGVyLCBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlLCBVc2VyUHJlZmVyZW5jZVZhbHVlcyB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uSW5pdCwgT3V0cHV0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBGb3JtQ29udHJvbCwgRm9ybUdyb3VwLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRGF0ZUFkYXB0ZXIsIE1BVF9EQVRFX0ZPUk1BVFMgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudC1lczYnO1xuaW1wb3J0IHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtZGF0ZS1yYW5nZS13aWRnZXQnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9kYXRlLXJhbmdlLndpZGdldC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge3Byb3ZpZGU6IERhdGVBZGFwdGVyLCB1c2VDbGFzczogTW9tZW50RGF0ZUFkYXB0ZXJ9LFxuICAgICAgICB7cHJvdmlkZTogTUFUX0RBVEVfRk9STUFUUywgdXNlVmFsdWU6IE1PTUVOVF9EQVRFX0ZPUk1BVFN9XSxcbiAgICBzdHlsZVVybHM6IFsnLi9kYXRlLXJhbmdlLndpZGdldC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBEYXRlUmFuZ2VXaWRnZXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgcHVibGljIEZPUk1BVF9EQVRFX0FDVElWSVRJOiBzdHJpbmcgPSAnWVlZWS1NTS1ERCc7XG4gICAgcHVibGljIFNIT1dfRk9STUFUOiBzdHJpbmcgPSAnREQvTU0vWVlZWSc7XG5cbiAgICBASW5wdXQoJ2dyb3VwJylcbiAgICBwdWJsaWMgZGF0ZVJhbmdlOiBGb3JtR3JvdXA7XG5cbiAgICBASW5wdXQoKVxuICAgIGZpZWxkOiBhbnk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBkYXRlUmFuZ2VDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgbWluRGF0ZTogTW9tZW50O1xuICAgIG1heERhdGU6IE1vbWVudDtcbiAgICBzdGFydERhdGVQaWNrZXI6IE1vbWVudCA9IG1vbWVudCgpO1xuICAgIGVuZERhdGVQaWNrZXI6IE1vbWVudCA9IG1vbWVudCgpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyPE1vbWVudD4sXG4gICAgICAgIHByaXZhdGUgdXNlclByZWZlcmVuY2VzU2VydmljZTogVXNlclByZWZlcmVuY2VzU2VydmljZSkge1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnVzZXJQcmVmZXJlbmNlc1NlcnZpY2Uuc2VsZWN0KFVzZXJQcmVmZXJlbmNlVmFsdWVzLkxvY2FsZSkuc3Vic2NyaWJlKChsb2NhbGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZUFkYXB0ZXIuc2V0TG9jYWxlKGxvY2FsZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBtb21lbnREYXRlQWRhcHRlciA9IDxNb21lbnREYXRlQWRhcHRlcj4gdGhpcy5kYXRlQWRhcHRlcjtcbiAgICAgICAgbW9tZW50RGF0ZUFkYXB0ZXIub3ZlcnJpZGVEaXNwbGF5Rm9ybWF0ID0gdGhpcy5TSE9XX0ZPUk1BVDtcblxuICAgICAgICBpZiAodGhpcy5maWVsZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmllbGQudmFsdWUgJiYgdGhpcy5maWVsZC52YWx1ZS5zdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RGF0ZVBpY2tlciA9IG1vbWVudCh0aGlzLmZpZWxkLnZhbHVlLnN0YXJ0RGF0ZSwgdGhpcy5GT1JNQVRfREFURV9BQ1RJVklUSSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmZpZWxkLnZhbHVlICYmIHRoaXMuZmllbGQudmFsdWUuZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kRGF0ZVBpY2tlciA9IG1vbWVudCh0aGlzLmZpZWxkLnZhbHVlLmVuZERhdGUsIHRoaXMuRk9STUFUX0RBVEVfQUNUSVZJVEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXJ0RGF0ZUNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2wodGhpcy5zdGFydERhdGVQaWNrZXIpO1xuICAgICAgICBzdGFydERhdGVDb250cm9sLnNldFZhbGlkYXRvcnMoVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlLmFkZENvbnRyb2woJ3N0YXJ0RGF0ZScsIHN0YXJ0RGF0ZUNvbnRyb2wpO1xuXG4gICAgICAgIGxldCBlbmREYXRlQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCh0aGlzLmVuZERhdGVQaWNrZXIpO1xuICAgICAgICBlbmREYXRlQ29udHJvbC5zZXRWYWxpZGF0b3JzKFZhbGlkYXRvcnMucmVxdWlyZWQpO1xuICAgICAgICB0aGlzLmRhdGVSYW5nZS5hZGRDb250cm9sKCdlbmREYXRlJywgZW5kRGF0ZUNvbnRyb2wpO1xuXG4gICAgICAgIHRoaXMuZGF0ZVJhbmdlLnNldFZhbGlkYXRvcnModGhpcy5kYXRlQ2hlY2spO1xuICAgICAgICB0aGlzLmRhdGVSYW5nZS52YWx1ZUNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMub25Hcm91cFZhbHVlQ2hhbmdlZCgpKTtcbiAgICB9XG5cbiAgICBvbkdyb3VwVmFsdWVDaGFuZ2VkKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRlUmFuZ2UudmFsaWQpIHtcbiAgICAgICAgICAgIGxldCBkYXRlU3RhcnQgPSB0aGlzLmNvbnZlcnRUb01vbWVudERhdGVXaXRoVGltZSh0aGlzLmRhdGVSYW5nZS5jb250cm9scy5zdGFydERhdGUudmFsdWUpO1xuICAgICAgICAgICAgbGV0IGVuZFN0YXJ0ID0gdGhpcy5jb252ZXJ0VG9Nb21lbnREYXRlV2l0aFRpbWUodGhpcy5kYXRlUmFuZ2UuY29udHJvbHMuZW5kRGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRhdGVSYW5nZUNoYW5nZWQuZW1pdCh7c3RhcnREYXRlOiBkYXRlU3RhcnQsIGVuZERhdGU6IGVuZFN0YXJ0fSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb252ZXJ0VG9Nb21lbnREYXRlV2l0aFRpbWUoZGF0ZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQoZGF0ZSwgdGhpcy5GT1JNQVRfREFURV9BQ1RJVklUSSwgdHJ1ZSkuZm9ybWF0KHRoaXMuRk9STUFUX0RBVEVfQUNUSVZJVEkpICsgJ1QwMDowMDowMC4wMDBaJztcbiAgICB9XG5cbiAgICBkYXRlQ2hlY2soZm9ybUNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCkge1xuICAgICAgICBsZXQgc3RhcnREYXRlID0gbW9tZW50KGZvcm1Db250cm9sLmdldCgnc3RhcnREYXRlJykudmFsdWUpO1xuICAgICAgICBsZXQgZW5kRGF0ZSA9IG1vbWVudChmb3JtQ29udHJvbC5nZXQoJ2VuZERhdGUnKS52YWx1ZSk7XG4gICAgICAgIGxldCBpc0FmdGVyQ2hlY2sgPSBzdGFydERhdGUuaXNBZnRlcihlbmREYXRlKTtcbiAgICAgICAgcmV0dXJuIGlzQWZ0ZXJDaGVjayA/IHsnZ3JlYXRlclRoYW4nOiB0cnVlfSA6IG51bGw7XG4gICAgfVxuXG4gICAgaXNTdGFydERhdGVHcmVhdGVyVGhhbkVuZERhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZSAmJiB0aGlzLmRhdGVSYW5nZS5lcnJvcnMgJiYgdGhpcy5kYXRlUmFuZ2UuZXJyb3JzLmdyZWF0ZXJUaGFuO1xuICAgIH1cblxuICAgIGlzU3RhcnREYXRlRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZSAmJiB0aGlzLmRhdGVSYW5nZS5jb250cm9scy5zdGFydERhdGUgJiYgIXRoaXMuZGF0ZVJhbmdlLmNvbnRyb2xzLnN0YXJ0RGF0ZS52YWxpZDtcbiAgICB9XG59XG4iXX0=