/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { TestBed } from '@angular/core/testing';
/**
 * @record
 */
function DoneFn() { }
if (false) {
    /** @type {?} */
    DoneFn.prototype.fail;
    /* Skipping unhandled member: (): void;*/
}
/** @type {?} */
const resetTestingModule = TestBed.resetTestingModule;
/** @type {?} */
const preventAngularFromResetting = () => (TestBed.resetTestingModule = () => TestBed);
const ɵ0 = preventAngularFromResetting;
/** @type {?} */
const allowAngularToReset = () => (TestBed.resetTestingModule = resetTestingModule);
const ɵ1 = allowAngularToReset;
/** @type {?} */
export const setupTestBed = (moduleDef) => {
    beforeAll((done) => (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
        localStorage.clear();
        sessionStorage.clear();
        resetTestingModule();
        preventAngularFromResetting();
        TestBed.configureTestingModule(moduleDef);
        yield TestBed.compileComponents();
        // prevent Angular from resetting testing module
        TestBed.resetTestingModule = () => TestBed;
    }))()
        .then(done)
        .catch(done.fail));
    afterAll(() => allowAngularToReset());
};
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0dXBUZXN0QmVkLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb3JlLyIsInNvdXJjZXMiOlsidGVzdGluZy9zZXR1cFRlc3RCZWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxPQUFPLEVBQXNCLE1BQU0sdUJBQXVCLENBQUM7Ozs7QUFFcEUscUJBR0M7OztJQURHLHNCQUF5Qzs7OztNQU12QyxrQkFBa0IsR0FBRyxPQUFPLENBQUMsa0JBQWtCOztNQUMvQywyQkFBMkIsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUM7OztNQUNoRixtQkFBbUIsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQzs7O0FBRW5GLE1BQU0sT0FBTyxZQUFZLEdBQUcsQ0FBQyxTQUE2QixFQUFFLEVBQUU7SUFDMUQsU0FBUyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FDZixDQUFDLEdBQVMsRUFBRTtRQUNSLFlBQVksQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNyQixjQUFjLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDdkIsa0JBQWtCLEVBQUUsQ0FBQztRQUNyQiwyQkFBMkIsRUFBRSxDQUFDO1FBQzlCLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMxQyxNQUFNLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBRWxDLGdEQUFnRDtRQUNoRCxPQUFPLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDO0lBQy9DLENBQUMsQ0FBQSxDQUFDLEVBQUU7U0FDQyxJQUFJLENBQUMsSUFBSSxDQUFDO1NBQ1YsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDeEIsQ0FBQztJQUVGLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLENBQUM7QUFDMUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFRlc3RCZWQsIFRlc3RNb2R1bGVNZXRhZGF0YSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvdGVzdGluZyc7XG5cbmludGVyZmFjZSBEb25lRm4gZXh0ZW5kcyBGdW5jdGlvbiB7XG4gICAgKCk6IHZvaWQ7XG4gICAgZmFpbDogKG1lc3NhZ2U/OiBFcnJvciB8IHN0cmluZykgPT4gdm9pZDtcbn1cblxuZGVjbGFyZSBmdW5jdGlvbiBiZWZvcmVBbGwoYWN0aW9uOiAoZG9uZTogRG9uZUZuKSA9PiB2b2lkLCB0aW1lb3V0PzogbnVtYmVyKTogdm9pZDtcbmRlY2xhcmUgZnVuY3Rpb24gYWZ0ZXJBbGwoYWN0aW9uOiAoZG9uZTogRG9uZUZuKSA9PiB2b2lkLCB0aW1lb3V0PzogbnVtYmVyKTogdm9pZDtcblxuY29uc3QgcmVzZXRUZXN0aW5nTW9kdWxlID0gVGVzdEJlZC5yZXNldFRlc3RpbmdNb2R1bGU7XG5jb25zdCBwcmV2ZW50QW5ndWxhckZyb21SZXNldHRpbmcgPSAoKSA9PiAoVGVzdEJlZC5yZXNldFRlc3RpbmdNb2R1bGUgPSAoKSA9PiBUZXN0QmVkKTtcbmNvbnN0IGFsbG93QW5ndWxhclRvUmVzZXQgPSAoKSA9PiAoVGVzdEJlZC5yZXNldFRlc3RpbmdNb2R1bGUgPSByZXNldFRlc3RpbmdNb2R1bGUpO1xuXG5leHBvcnQgY29uc3Qgc2V0dXBUZXN0QmVkID0gKG1vZHVsZURlZjogVGVzdE1vZHVsZU1ldGFkYXRhKSA9PiB7XG4gICAgYmVmb3JlQWxsKChkb25lKSA9PlxuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmNsZWFyKCk7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5jbGVhcigpO1xuICAgICAgICAgICAgcmVzZXRUZXN0aW5nTW9kdWxlKCk7XG4gICAgICAgICAgICBwcmV2ZW50QW5ndWxhckZyb21SZXNldHRpbmcoKTtcbiAgICAgICAgICAgIFRlc3RCZWQuY29uZmlndXJlVGVzdGluZ01vZHVsZShtb2R1bGVEZWYpO1xuICAgICAgICAgICAgYXdhaXQgVGVzdEJlZC5jb21waWxlQ29tcG9uZW50cygpO1xuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IEFuZ3VsYXIgZnJvbSByZXNldHRpbmcgdGVzdGluZyBtb2R1bGVcbiAgICAgICAgICAgIFRlc3RCZWQucmVzZXRUZXN0aW5nTW9kdWxlID0gKCkgPT4gVGVzdEJlZDtcbiAgICAgICAgfSkoKVxuICAgICAgICAgICAgLnRoZW4oZG9uZSlcbiAgICAgICAgICAgIC5jYXRjaChkb25lLmZhaWwpXG4gICAgKTtcblxuICAgIGFmdGVyQWxsKCgpID0+IGFsbG93QW5ndWxhclRvUmVzZXQoKSk7XG59O1xuIl19