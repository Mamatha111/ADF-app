/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Injectable } from '@angular/core';
import { from, of } from 'rxjs';
import { map, switchMap } from 'rxjs/operators';
import { IdentityUserModel } from '../models/identity-user.model';
import { JwtHelperService } from '../../services/jwt-helper.service';
import { AppConfigService } from '../../app-config/app-config.service';
import { AlfrescoApiService } from '../../services/alfresco-api.service';
import * as i0 from "@angular/core";
import * as i1 from "../../services/jwt-helper.service";
import * as i2 from "../../services/alfresco-api.service";
import * as i3 from "../../app-config/app-config.service";
export class IdentityUserService {
    /**
     * @param {?} helper
     * @param {?} apiService
     * @param {?} appConfigService
     */
    constructor(helper, apiService, appConfigService) {
        this.helper = helper;
        this.apiService = apiService;
        this.appConfigService = appConfigService;
    }
    /**
     * Gets the name and other basic details of the current user.
     * @return {?} The user's details
     */
    getCurrentUserInfo() {
        /** @type {?} */
        const familyName = this.getValueFromToken(IdentityUserService.FAMILY_NAME);
        /** @type {?} */
        const givenName = this.getValueFromToken(IdentityUserService.GIVEN_NAME);
        /** @type {?} */
        const email = this.getValueFromToken(IdentityUserService.USER_EMAIL);
        /** @type {?} */
        const username = this.getValueFromToken(IdentityUserService.USER_PREFERRED_USERNAME);
        /** @type {?} */
        const user = { firstName: givenName, lastName: familyName, email: email, username: username };
        return new IdentityUserModel(user);
    }
    /**
     * Gets a named value from the user access token.
     * @template T
     * @param {?} key Key name of the field to retrieve
     * @return {?} Value from the token
     */
    getValueFromToken(key) {
        /** @type {?} */
        let value;
        /** @type {?} */
        const token = localStorage.getItem(IdentityUserService.USER_ACCESS_TOKEN);
        if (token) {
            /** @type {?} */
            const tokenPayload = this.helper.decodeToken(token);
            value = tokenPayload[key];
        }
        return (/** @type {?} */ (value));
    }
    /**
     * Find users based on search input.
     * @param {?} search Search query string
     * @return {?} List of users
     */
    findUsersByName(search) {
        if (search === '') {
            return of([]);
        }
        /** @type {?} */
        const url = this.buildUserUrl();
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = { search: search };
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return (from(this.apiService.getInstance().oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, Object, null, null)));
    }
    /**
     * Get client roles of a user for a particular client.
     * @param {?} userId ID of the target user
     * @param {?} clientId ID of the client app
     * @return {?} List of client roles
     */
    getClientRoles(userId, clientId) {
        /** @type {?} */
        const url = this.buildUserClientRoleMapping(userId, clientId);
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = {};
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return from(this.apiService.getInstance().oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, Object, null, null));
    }
    /**
     * Checks whether user has access to a client app.
     * @param {?} userId ID of the target user
     * @param {?} clientId ID of the client app
     * @return {?} True if the user has access, false otherwise
     */
    checkUserHasClientApp(userId, clientId) {
        return this.getClientRoles(userId, clientId).pipe(map((clientRoles) => {
            if (clientRoles.length > 0) {
                return true;
            }
            return false;
        }));
    }
    /**
     * Checks whether a user has any of the client app roles.
     * @param {?} userId ID of the target user
     * @param {?} clientId ID of the client app
     * @param {?} roleNames List of role names to check for
     * @return {?} True if the user has one or more of the roles, false otherwise
     */
    checkUserHasAnyClientAppRole(userId, clientId, roleNames) {
        return this.getClientRoles(userId, clientId).pipe(map((clientRoles) => {
            /** @type {?} */
            let hasRole = false;
            if (clientRoles.length > 0) {
                roleNames.forEach((roleName) => {
                    /** @type {?} */
                    const role = clientRoles.find((availableRole) => {
                        return availableRole.name === roleName;
                    });
                    if (role) {
                        hasRole = true;
                        return;
                    }
                });
            }
            return hasRole;
        }));
    }
    /**
     * Gets the client ID for an application.
     * @param {?} applicationName Name of the application
     * @return {?} Client ID string
     */
    getClientIdByApplicationName(applicationName) {
        /** @type {?} */
        const url = this.buildGetClientsUrl();
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = { clientId: applicationName };
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return from(this.apiService.getInstance()
            .oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, Object, null, null)).pipe(map((response) => {
            /** @type {?} */
            const clientId = response && response.length > 0 ? response[0].id : '';
            return clientId;
        }));
    }
    /**
     * Checks if a user has access to an application.
     * @param {?} userId ID of the user
     * @param {?} applicationName Name of the application
     * @return {?} True if the user has access, false otherwise
     */
    checkUserHasApplicationAccess(userId, applicationName) {
        return this.getClientIdByApplicationName(applicationName).pipe(switchMap((clientId) => {
            return this.checkUserHasClientApp(userId, clientId);
        }));
    }
    /**
     * Checks if a user has any application role.
     * @param {?} userId ID of the target user
     * @param {?} applicationName Name of the application
     * @param {?} roleNames List of role names to check for
     * @return {?} True if the user has one or more of the roles, false otherwise
     */
    checkUserHasAnyApplicationRole(userId, applicationName, roleNames) {
        return this.getClientIdByApplicationName(applicationName).pipe(switchMap((clientId) => {
            return this.checkUserHasAnyClientAppRole(userId, clientId, roleNames);
        }));
    }
    /**
     * Gets details for all users.
     * @return {?} Array of user info objects
     */
    getUsers() {
        /** @type {?} */
        const url = this.buildUserUrl();
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = {};
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const authNames = [];
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return from(this.apiService.getInstance().oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, authNames, contentTypes, accepts, null, null)).pipe(map((response) => {
            return response;
        }));
    }
    /**
     * Gets a list of roles for a user.
     * @param {?} userId ID of the user
     * @return {?} Array of role info objects
     */
    getUserRoles(userId) {
        /** @type {?} */
        const url = this.buildRolesUrl(userId);
        /** @type {?} */
        const httpMethod = 'GET';
        /** @type {?} */
        const pathParams = {};
        /** @type {?} */
        const queryParams = {};
        /** @type {?} */
        const bodyParam = {};
        /** @type {?} */
        const headerParams = {};
        /** @type {?} */
        const formParams = {};
        /** @type {?} */
        const contentTypes = ['application/json'];
        /** @type {?} */
        const accepts = ['application/json'];
        return from(this.apiService.getInstance().oauth2Auth.callCustomApi(url, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, Object, null, null)).pipe(map((response) => {
            return response;
        }));
    }
    /**
     * Gets an array of users (including the current user) who have any of the roles in the supplied list.
     * @param {?} roleNames List of role names to look for
     * @return {?} Array of user info objects
     */
    getUsersByRolesWithCurrentUser(roleNames) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const filteredUsers = [];
            if (roleNames && roleNames.length > 0) {
                /** @type {?} */
                const users = yield this.getUsers().toPromise();
                for (let i = 0; i < users.length; i++) {
                    /** @type {?} */
                    const hasAnyRole = yield this.userHasAnyRole(users[i].id, roleNames);
                    if (hasAnyRole) {
                        filteredUsers.push(users[i]);
                    }
                }
            }
            return filteredUsers;
        });
    }
    /**
     * Gets an array of users (not including the current user) who have any of the roles in the supplied list.
     * @param {?} roleNames List of role names to look for
     * @return {?} Array of user info objects
     */
    getUsersByRolesWithoutCurrentUser(roleNames) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const filteredUsers = [];
            if (roleNames && roleNames.length > 0) {
                /** @type {?} */
                const currentUser = this.getCurrentUserInfo();
                /** @type {?} */
                let users = yield this.getUsers().toPromise();
                users = users.filter((user) => { return user.username !== currentUser.username; });
                for (let i = 0; i < users.length; i++) {
                    /** @type {?} */
                    const hasAnyRole = yield this.userHasAnyRole(users[i].id, roleNames);
                    if (hasAnyRole) {
                        filteredUsers.push(users[i]);
                    }
                }
            }
            return filteredUsers;
        });
    }
    /**
     * @private
     * @param {?} userId
     * @param {?} roleNames
     * @return {?}
     */
    userHasAnyRole(userId, roleNames) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const userRoles = yield this.getUserRoles(userId).toPromise();
            /** @type {?} */
            const hasAnyRole = roleNames.some((roleName) => {
                /** @type {?} */
                const filteredRoles = userRoles.filter((userRole) => {
                    return userRole.name.toLocaleLowerCase() === roleName.toLocaleLowerCase();
                });
                return filteredRoles.length > 0;
            });
            return hasAnyRole;
        });
    }
    /**
     * Checks if a user has one of the roles from a list.
     * @param {?} userId ID of the target user
     * @param {?} roleNames Array of roles to check for
     * @return {?} True if the user has one of the roles, false otherwise
     */
    checkUserHasRole(userId, roleNames) {
        return this.getUserRoles(userId).pipe(map((userRoles) => {
            /** @type {?} */
            let hasRole = false;
            if (userRoles && userRoles.length > 0) {
                roleNames.forEach((roleName) => {
                    /** @type {?} */
                    const role = userRoles.find((userRole) => {
                        return roleName === userRole.name;
                    });
                    if (role) {
                        hasRole = true;
                        return;
                    }
                });
            }
            return hasRole;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    buildUserUrl() {
        return `${this.appConfigService.get('identityHost')}/users`;
    }
    /**
     * @private
     * @param {?} userId
     * @param {?} clientId
     * @return {?}
     */
    buildUserClientRoleMapping(userId, clientId) {
        return `${this.appConfigService.get('identityHost')}/users/${userId}/role-mappings/clients/${clientId}`;
    }
    /**
     * @private
     * @param {?} userId
     * @return {?}
     */
    buildRolesUrl(userId) {
        return `${this.appConfigService.get('identityHost')}/users/${userId}/role-mappings/realm/composite`;
    }
    /**
     * @private
     * @return {?}
     */
    buildGetClientsUrl() {
        return `${this.appConfigService.get('identityHost')}/clients`;
    }
}
IdentityUserService.USER_NAME = 'name';
IdentityUserService.FAMILY_NAME = 'family_name';
IdentityUserService.GIVEN_NAME = 'given_name';
IdentityUserService.USER_EMAIL = 'email';
IdentityUserService.USER_ACCESS_TOKEN = 'access_token';
IdentityUserService.USER_PREFERRED_USERNAME = 'preferred_username';
IdentityUserService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
IdentityUserService.ctorParameters = () => [
    { type: JwtHelperService },
    { type: AlfrescoApiService },
    { type: AppConfigService }
];
/** @nocollapse */ IdentityUserService.ngInjectableDef = i0.defineInjectable({ factory: function IdentityUserService_Factory() { return new IdentityUserService(i0.inject(i1.JwtHelperService), i0.inject(i2.AlfrescoApiService), i0.inject(i3.AppConfigService)); }, token: IdentityUserService, providedIn: "root" });
if (false) {
    /** @type {?} */
    IdentityUserService.USER_NAME;
    /** @type {?} */
    IdentityUserService.FAMILY_NAME;
    /** @type {?} */
    IdentityUserService.GIVEN_NAME;
    /** @type {?} */
    IdentityUserService.USER_EMAIL;
    /** @type {?} */
    IdentityUserService.USER_ACCESS_TOKEN;
    /** @type {?} */
    IdentityUserService.USER_PREFERRED_USERNAME;
    /**
     * @type {?}
     * @private
     */
    IdentityUserService.prototype.helper;
    /**
     * @type {?}
     * @private
     */
    IdentityUserService.prototype.apiService;
    /**
     * @type {?}
     * @private
     */
    IdentityUserService.prototype.appConfigService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWRlbnRpdHktdXNlci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb3JlLyIsInNvdXJjZXMiOlsidXNlcmluZm8vc2VydmljZXMvaWRlbnRpdHktdXNlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBYyxJQUFJLEVBQUUsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzVDLE9BQU8sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFaEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDbEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDckUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDdkUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUNBQXFDLENBQUM7Ozs7O0FBTXpFLE1BQU0sT0FBTyxtQkFBbUI7Ozs7OztJQVM1QixZQUNZLE1BQXdCLEVBQ3hCLFVBQThCLEVBQzlCLGdCQUFrQztRQUZsQyxXQUFNLEdBQU4sTUFBTSxDQUFrQjtRQUN4QixlQUFVLEdBQVYsVUFBVSxDQUFvQjtRQUM5QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO0lBQUcsQ0FBQzs7Ozs7SUFNbEQsa0JBQWtCOztjQUNSLFVBQVUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQVMsbUJBQW1CLENBQUMsV0FBVyxDQUFDOztjQUM1RSxTQUFTLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFTLG1CQUFtQixDQUFDLFVBQVUsQ0FBQzs7Y0FDMUUsS0FBSyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBUyxtQkFBbUIsQ0FBQyxVQUFVLENBQUM7O2NBQ3RFLFFBQVEsR0FBRyxJ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QUMxQiw4QkFBVSxHQUFHLE9BQU8sQ0FBQztBQUNyQixxQ0FBaUIsR0FBRyxjQUFjLENBQUM7QUFDbkMsMkNBQXVCLEdBQUcsb0JBQW9CLENBQUM7O1lBVnpELFVBQVUsU0FBQztnQkFDUixVQUFVLEVBQUUsTUFBTTthQUNyQjs7OztZQVBRLGdCQUFnQjtZQUVoQixrQkFBa0I7WUFEbEIsZ0JBQWdCOzs7OztJQVNyQiw4QkFBMEI7O0lBQzFCLGdDQUFtQzs7SUFDbkMsK0JBQWlDOztJQUNqQywrQkFBNEI7O0lBQzVCLHNDQUEwQzs7SUFDMUMsNENBQXNEOzs7OztJQUdsRCxxQ0FBZ0M7Ozs7O0lBQ2hDLHlDQUFzQzs7Ozs7SUFDdEMsK0NBQTBDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZnJvbSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBJZGVudGl0eVVzZXJNb2RlbCB9IGZyb20gJy4uL21vZGVscy9pZGVudGl0eS11c2VyLm1vZGVsJztcbmltcG9ydCB7IEp3dEhlbHBlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9qd3QtaGVscGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQXBwQ29uZmlnU2VydmljZSB9IGZyb20gJy4uLy4uL2FwcC1jb25maWcvYXBwLWNvbmZpZy5zZXJ2aWNlJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2FsZnJlc2NvLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElkZW50aXR5Um9sZU1vZGVsIH0gZnJvbSAnLi4vbW9kZWxzL2lkZW50aXR5LXJvbGUubW9kZWwnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIElkZW50aXR5VXNlclNlcnZpY2Uge1xuXG4gICAgc3RhdGljIFVTRVJfTkFNRSA9ICduYW1lJztcbiAgICBzdGF0aWMgRkFNSUxZX05BTUUgPSAnZmFtaWx5X25hbWUnO1xuICAgIHN0YXRpYyBHSVZFTl9OQU1FID0gJ2dpdmVuX25hbWUnO1xuICAgIHN0YXRpYyBVU0VSX0VNQUlMID0gJ2VtYWlsJztcbiAgICBzdGF0aWMgVVNFUl9BQ0NFU1NfVE9LRU4gPSAnYWNjZXNzX3Rva2VuJztcbiAgICBzdGF0aWMgVVNFUl9QUkVGRVJSRURfVVNFUk5BTUUgPSAncHJlZmVycmVkX3VzZXJuYW1lJztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGhlbHBlcjogSnd0SGVscGVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgYXBwQ29uZmlnU2VydmljZTogQXBwQ29uZmlnU2VydmljZSkge31cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgYW5kIG90aGVyIGJhc2ljIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcmV0dXJucyBUaGUgdXNlcidzIGRldGFpbHNcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50VXNlckluZm8oKTogSWRlbnRpdHlVc2VyTW9kZWwge1xuICAgICAgICBjb25zdCBmYW1pbHlOYW1lID0gdGhpcy5nZXRWYWx1ZUZyb21Ub2tlbjxzdHJpbmc+KElkZW50aXR5VXNlclNlcnZpY2UuRkFNSUxZX05BTUUpO1xuICAgICAgICBjb25zdCBnaXZlbk5hbWUgPSB0aGlzLmdldFZhbHVlRnJvbVRva2VuPHN0cmluZz4oSWRlbnRpdHlVc2VyU2VydmljZS5HSVZFTl9OQU1FKTtcbiAgICAgICAgY29uc3QgZW1haWwgPSB0aGlzLmdldFZhbHVlRnJvbVRva2VuPHN0cmluZz4oSWRlbnRpdHlVc2VyU2VydmljZS5VU0VSX0VNQUlMKTtcbiAgICAgICAgY29uc3QgdXNlcm5hbWUgPSB0aGlzLmdldFZhbHVlRnJvbVRva2VuPHN0cmluZz4oSWRlbnRpdHlVc2VyU2VydmljZS5VU0VSX1BSRUZFUlJFRF9VU0VSTkFNRSk7XG4gICAgICAgIGNvbnN0IHVzZXIgPSB7IGZpcnN0TmFtZTogZ2l2ZW5OYW1lLCBsYXN0TmFtZTogZmFtaWx5TmFtZSwgZW1haWw6IGVtYWlsLCB1c2VybmFtZTogdXNlcm5hbWUgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBJZGVudGl0eVVzZXJNb2RlbCh1c2VyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmFtZWQgdmFsdWUgZnJvbSB0aGUgdXNlciBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIGtleSBLZXkgbmFtZSBvZiB0aGUgZmllbGQgdG8gcmV0cmlldmVcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBmcm9tIHRoZSB0b2tlblxuICAgICAqL1xuICAgIGdldFZhbHVlRnJvbVRva2VuPFQ+KGtleTogc3RyaW5nKTogVCB7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShJZGVudGl0eVVzZXJTZXJ2aWNlLlVTRVJfQUNDRVNTX1RPS0VOKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlblBheWxvYWQgPSB0aGlzLmhlbHBlci5kZWNvZGVUb2tlbih0b2tlbik7XG4gICAgICAgICAgICB2YWx1ZSA9IHRva2VuUGF5bG9hZFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiA8VD4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCB1c2VycyBiYXNlZCBvbiBzZWFyY2ggaW5wdXQuXG4gICAgICogQHBhcmFtIHNlYXJjaCBTZWFyY2ggcXVlcnkgc3RyaW5nXG4gICAgICogQHJldHVybnMgTGlzdCBvZiB1c2Vyc1xuICAgICAqL1xuICAgIGZpbmRVc2Vyc0J5TmFtZShzZWFyY2g6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIGlmIChzZWFyY2ggPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gb2YoW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRVc2VyVXJsKCk7XG4gICAgICAgIGNvbnN0IGh0dHBNZXRob2QgPSAnR0VUJywgcGF0aFBhcmFtcyA9IHt9LCBxdWVyeVBhcmFtcyA9IHtzZWFyY2g6IHNlYXJjaH0sIGJvZHlQYXJhbSA9IHt9LCBoZWFkZXJQYXJhbXMgPSB7fSxcbiAgICAgICAgICAgIGZvcm1QYXJhbXMgPSB7fSwgY29udGVudFR5cGVzID0gWydhcHBsaWNhdGlvbi9qc29uJ10sIGFjY2VwdHMgPSBbJ2FwcGxpY2F0aW9uL2pzb24nXTtcblxuICAgICAgICByZXR1cm4gKGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkub2F1dGgyQXV0aC5jYWxsQ3VzdG9tQXBpKFxuICAgICAgICAgICAgICAgICAgICB1cmwsIGh0dHBNZXRob2QsIHBhdGhQYXJhbXMsIHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbXMsIGZvcm1QYXJhbXMsIGJvZHlQYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVzLCBhY2NlcHRzLCBPYmplY3QsIG51bGwsIG51bGwpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNsaWVudCByb2xlcyBvZiBhIHVzZXIgZm9yIGEgcGFydGljdWxhciBjbGllbnQuXG4gICAgICogQHBhcmFtIHVzZXJJZCBJRCBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgSUQgb2YgdGhlIGNsaWVudCBhcHBcbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIGNsaWVudCByb2xlc1xuICAgICAqL1xuICAgIGdldENsaWVudFJvbGVzKHVzZXJJZDogc3RyaW5nLCBjbGllbnRJZDogc3RyaW5nKTogT2JzZXJ2YWJsZTxhbnlbXT4ge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVXNlckNsaWVudFJvbGVNYXBwaW5nKHVzZXJJZCwgY2xpZW50SWQpO1xuICAgICAgICBjb25zdCBodHRwTWV0aG9kID0gJ0dFVCcsIHBhdGhQYXJhbXMgPSB7fSwgcXVlcnlQYXJhbXMgPSB7fSwgYm9keVBhcmFtID0ge30sIGhlYWRlclBhcmFtcyA9IHt9LFxuICAgICAgICAgICAgZm9ybVBhcmFtcyA9IHt9LCBjb250ZW50VHlwZXMgPSBbJ2FwcGxpY2F0aW9uL2pzb24nXSwgYWNjZXB0cyA9IFsnYXBwbGljYXRpb24vanNvbiddO1xuXG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLm9hdXRoMkF1dGguY2FsbEN1c3RvbUFwaShcbiAgICAgICAgICAgICAgICAgICAgdXJsLCBodHRwTWV0aG9kLCBwYXRoUGFyYW1zLCBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1zLCBmb3JtUGFyYW1zLCBib2R5UGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlcywgYWNjZXB0cywgT2JqZWN0LCBudWxsLCBudWxsKVxuICAgICAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdXNlciBoYXMgYWNjZXNzIHRvIGEgY2xpZW50IGFwcC5cbiAgICAgKiBAcGFyYW0gdXNlcklkIElEIG9mIHRoZSB0YXJnZXQgdXNlclxuICAgICAqIEBwYXJhbSBjbGllbnRJZCBJRCBvZiB0aGUgY2xpZW50IGFwcFxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHVzZXIgaGFzIGFjY2VzcywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgY2hlY2tVc2VySGFzQ2xpZW50QXBwKHVzZXJJZDogc3RyaW5nLCBjbGllbnRJZDogc3RyaW5nKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENsaWVudFJvbGVzKHVzZXJJZCwgY2xpZW50SWQpLnBpcGUoXG4gICAgICAgICAgICBtYXAoKGNsaWVudFJvbGVzOiBhbnlbXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjbGllbnRSb2xlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgdXNlciBoYXMgYW55IG9mIHRoZSBjbGllbnQgYXBwIHJvbGVzLlxuICAgICAqIEBwYXJhbSB1c2VySWQgSUQgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgICogQHBhcmFtIGNsaWVudElkIElEIG9mIHRoZSBjbGllbnQgYXBwXG4gICAgICogQHBhcmFtIHJvbGVOYW1lcyBMaXN0IG9mIHJvbGUgbmFtZXMgdG8gY2hlY2sgZm9yXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdXNlciBoYXMgb25lIG9yIG1vcmUgb2YgdGhlIHJvbGVzLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBjaGVja1VzZXJIYXNBbnlDbGllbnRBcHBSb2xlKHVzZXJJZDogc3RyaW5nLCBjbGllbnRJZDogc3RyaW5nLCByb2xlTmFtZXM6IHN0cmluZ1tdKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENsaWVudFJvbGVzKHVzZXJJZCwgY2xpZW50SWQpLnBpcGUoXG4gICAgICAgICAgICBtYXAoKGNsaWVudFJvbGVzOiBhbnlbXSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBoYXNSb2xlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudFJvbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZU5hbWVzLmZvckVhY2goKHJvbGVOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb2xlID0gY2xpZW50Um9sZXMuZmluZCgoYXZhaWxhYmxlUm9sZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGVSb2xlLm5hbWUgPT09IHJvbGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUm9sZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc1JvbGU7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNsaWVudCBJRCBmb3IgYW4gYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uTmFtZSBOYW1lIG9mIHRoZSBhcHBsaWNhdGlvblxuICAgICAqIEByZXR1cm5zIENsaWVudCBJRCBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXRDbGllbnRJZEJ5QXBwbGljYXRpb25OYW1lKGFwcGxpY2F0aW9uTmFtZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5idWlsZEdldENsaWVudHNVcmwoKTtcbiAgICAgICAgY29uc3QgaHR0cE1ldGhvZCA9ICdHRVQnLCBwYXRoUGFyYW1zID0ge30sIHF1ZXJ5UGFyYW1zID0ge2NsaWVudElkOiBhcHBsaWNhdGlvbk5hbWV9LCBib2R5UGFyYW0gPSB7fSwgaGVhZGVyUGFyYW1zID0ge30sIGZvcm1QYXJhbXMgPSB7fSxcbiAgICAgICAgICAgICAgY29udGVudFR5cGVzID0gWydhcHBsaWNhdGlvbi9qc29uJ10sIGFjY2VwdHMgPSBbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vYXV0aDJBdXRoLmNhbGxDdXN0b21BcGkodXJsLCBodHRwTWV0aG9kLCBwYXRoUGFyYW1zLCBxdWVyeVBhcmFtcywgaGVhZGVyUGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMsIGJvZHlQYXJhbSwgY29udGVudFR5cGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdHMsIE9iamVjdCwgbnVsbCwgbnVsbClcbiAgICAgICAgICAgICkucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHJlc3BvbnNlOiBhbnlbXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRJZCA9IHJlc3BvbnNlICYmIHJlc3BvbnNlLmxlbmd0aCA+IDAgPyByZXNwb25zZVswXS5pZCA6ICcnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50SWQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgdXNlciBoYXMgYWNjZXNzIHRvIGFuIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB1c2VySWQgSUQgb2YgdGhlIHVzZXJcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25OYW1lIE5hbWUgb2YgdGhlIGFwcGxpY2F0aW9uXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdXNlciBoYXMgYWNjZXNzLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBjaGVja1VzZXJIYXNBcHBsaWNhdGlvbkFjY2Vzcyh1c2VySWQ6IHN0cmluZywgYXBwbGljYXRpb25OYW1lOiBzdHJpbmcpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2xpZW50SWRCeUFwcGxpY2F0aW9uTmFtZShhcHBsaWNhdGlvbk5hbWUpLnBpcGUoXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKGNsaWVudElkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja1VzZXJIYXNDbGllbnRBcHAodXNlcklkLCBjbGllbnRJZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHVzZXIgaGFzIGFueSBhcHBsaWNhdGlvbiByb2xlLlxuICAgICAqIEBwYXJhbSB1c2VySWQgSUQgb2YgdGhlIHRhcmdldCB1c2VyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uTmFtZSBOYW1lIG9mIHRoZSBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSByb2xlTmFtZXMgTGlzdCBvZiByb2xlIG5hbWVzIHRvIGNoZWNrIGZvclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHVzZXIgaGFzIG9uZSBvciBtb3JlIG9mIHRoZSByb2xlcywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgY2hlY2tVc2VySGFzQW55QXBwbGljYXRpb25Sb2xlKHVzZXJJZDogc3RyaW5nLCBhcHBsaWNhdGlvbk5hbWU6IHN0cmluZywgcm9sZU5hbWVzOiBzdHJpbmdbXSk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDbGllbnRJZEJ5QXBwbGljYXRpb25OYW1lKGFwcGxpY2F0aW9uTmFtZSkucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoY2xpZW50SWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrVXNlckhhc0FueUNsaWVudEFwcFJvbGUodXNlcklkLCBjbGllbnRJZCwgcm9sZU5hbWVzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBkZXRhaWxzIGZvciBhbGwgdXNlcnMuXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgdXNlciBpbmZvIG9iamVjdHNcbiAgICAgKi9cbiAgICBnZXRVc2VycygpOiBPYnNlcnZhYmxlPElkZW50aXR5VXNlck1vZGVsW10+IHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVzZXJVcmwoKTtcbiAgICAgICAgY29uc3QgaHR0cE1ldGhvZCA9ICdHRVQnLCBwYXRoUGFyYW1zID0ge30sIHF1ZXJ5UGFyYW1zID0ge30sIGJvZHlQYXJhbSA9IHt9LCBoZWFkZXJQYXJhbXMgPSB7fSxcbiAgICAgICAgICAgIGZvcm1QYXJhbXMgPSB7fSwgYXV0aE5hbWVzID0gW10sIGNvbnRlbnRUeXBlcyA9IFsnYXBwbGljYXRpb24vanNvbiddLCBhY2NlcHRzID0gWydhcHBsaWNhdGlvbi9qc29uJ107XG5cbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkub2F1dGgyQXV0aC5jYWxsQ3VzdG9tQXBpKFxuICAgICAgICAgICAgICAgICAgICB1cmwsIGh0dHBNZXRob2QsIHBhdGhQYXJhbXMsIHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbXMsIGZvcm1QYXJhbXMsIGJvZHlQYXJhbSwgYXV0aE5hbWVzLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZXMsIGFjY2VwdHMsIG51bGwsIG51bGwpXG4gICAgICAgICAgICAgICAgKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICBtYXAoKHJlc3BvbnNlOiBJZGVudGl0eVVzZXJNb2RlbFtdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIHJvbGVzIGZvciBhIHVzZXIuXG4gICAgICogQHBhcmFtIHVzZXJJZCBJRCBvZiB0aGUgdXNlclxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIHJvbGUgaW5mbyBvYmplY3RzXG4gICAgICovXG4gICAgZ2V0VXNlclJvbGVzKHVzZXJJZDogc3RyaW5nKTogT2JzZXJ2YWJsZTxJZGVudGl0eVJvbGVNb2RlbFtdPiB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRSb2xlc1VybCh1c2VySWQpO1xuICAgICAgICBjb25zdCBodHRwTWV0aG9kID0gJ0dFVCcsIHBhdGhQYXJhbXMgPSB7fSwgcXVlcnlQYXJhbXMgPSB7fSwgYm9keVBhcmFtID0ge30sIGhlYWRlclBhcmFtcyA9IHt9LFxuICAgICAgICAgICAgZm9ybVBhcmFtcyA9IHt9LCBjb250ZW50VHlwZXMgPSBbJ2FwcGxpY2F0aW9uL2pzb24nXSwgYWNjZXB0cyA9IFsnYXBwbGljYXRpb24vanNvbiddO1xuXG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLm9hdXRoMkF1dGguY2FsbEN1c3RvbUFwaShcbiAgICAgICAgICAgICAgICAgICAgdXJsLCBodHRwTWV0aG9kLCBwYXRoUGFyYW1zLCBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1zLCBmb3JtUGFyYW1zLCBib2R5UGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlcywgYWNjZXB0cywgT2JqZWN0LCBudWxsLCBudWxsKVxuICAgICAgICAgICAgICAgICkucGlwZShcbiAgICAgICAgICAgICAgICAgICAgbWFwKChyZXNwb25zZTogSWRlbnRpdHlSb2xlTW9kZWxbXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuIGFycmF5IG9mIHVzZXJzIChpbmNsdWRpbmcgdGhlIGN1cnJlbnQgdXNlcikgd2hvIGhhdmUgYW55IG9mIHRoZSByb2xlcyBpbiB0aGUgc3VwcGxpZWQgbGlzdC5cbiAgICAgKiBAcGFyYW0gcm9sZU5hbWVzIExpc3Qgb2Ygcm9sZSBuYW1lcyB0byBsb29rIGZvclxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIHVzZXIgaW5mbyBvYmplY3RzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlcnNCeVJvbGVzV2l0aEN1cnJlbnRVc2VyKHJvbGVOYW1lczogc3RyaW5nW10pOiBQcm9taXNlPElkZW50aXR5VXNlck1vZGVsW10+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRVc2VyczogSWRlbnRpdHlVc2VyTW9kZWxbXSA9IFtdO1xuICAgICAgICBpZiAocm9sZU5hbWVzICYmIHJvbGVOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHRoaXMuZ2V0VXNlcnMoKS50b1Byb21pc2UoKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1c2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0FueVJvbGUgPSBhd2FpdCB0aGlzLnVzZXJIYXNBbnlSb2xlKHVzZXJzW2ldLmlkLCByb2xlTmFtZXMpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNBbnlSb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkVXNlcnMucHVzaCh1c2Vyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkVXNlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBhcnJheSBvZiB1c2VycyAobm90IGluY2x1ZGluZyB0aGUgY3VycmVudCB1c2VyKSB3aG8gaGF2ZSBhbnkgb2YgdGhlIHJvbGVzIGluIHRoZSBzdXBwbGllZCBsaXN0LlxuICAgICAqIEBwYXJhbSByb2xlTmFtZXMgTGlzdCBvZiByb2xlIG5hbWVzIHRvIGxvb2sgZm9yXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgdXNlciBpbmZvIG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2Vyc0J5Um9sZXNXaXRob3V0Q3VycmVudFVzZXIocm9sZU5hbWVzOiBzdHJpbmdbXSk6IFByb21pc2U8SWRlbnRpdHlVc2VyTW9kZWxbXT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFVzZXJzOiBJZGVudGl0eVVzZXJNb2RlbFtdID0gW107XG4gICAgICAgIGlmIChyb2xlTmFtZXMgJiYgcm9sZU5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gdGhpcy5nZXRDdXJyZW50VXNlckluZm8oKTtcbiAgICAgICAgICAgIGxldCB1c2VycyA9IGF3YWl0IHRoaXMuZ2V0VXNlcnMoKS50b1Byb21pc2UoKTtcblxuICAgICAgICAgICAgdXNlcnMgPSB1c2Vycy5maWx0ZXIoKHVzZXIpID0+IHsgcmV0dXJuIHVzZXIudXNlcm5hbWUgIT09IGN1cnJlbnRVc2VyLnVzZXJuYW1lOyB9KTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1c2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0FueVJvbGUgPSBhd2FpdCB0aGlzLnVzZXJIYXNBbnlSb2xlKHVzZXJzW2ldLmlkLCByb2xlTmFtZXMpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNBbnlSb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkVXNlcnMucHVzaCh1c2Vyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkVXNlcnM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyB1c2VySGFzQW55Um9sZSh1c2VySWQ6IHN0cmluZywgcm9sZU5hbWVzOiBzdHJpbmdbXSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCB1c2VyUm9sZXMgPSBhd2FpdCB0aGlzLmdldFVzZXJSb2xlcyh1c2VySWQpLnRvUHJvbWlzZSgpO1xuICAgICAgICBjb25zdCBoYXNBbnlSb2xlID0gcm9sZU5hbWVzLnNvbWUoKHJvbGVOYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFJvbGVzID0gdXNlclJvbGVzLmZpbHRlcigodXNlclJvbGUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlclJvbGUubmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSByb2xlTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZFJvbGVzLmxlbmd0aCA+IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBoYXNBbnlSb2xlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHVzZXIgaGFzIG9uZSBvZiB0aGUgcm9sZXMgZnJvbSBhIGxpc3QuXG4gICAgICogQHBhcmFtIHVzZXJJZCBJRCBvZiB0aGUgdGFyZ2V0IHVzZXJcbiAgICAgKiBAcGFyYW0gcm9sZU5hbWVzIEFycmF5IG9mIHJvbGVzIHRvIGNoZWNrIGZvclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHVzZXIgaGFzIG9uZSBvZiB0aGUgcm9sZXMsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGNoZWNrVXNlckhhc1JvbGUodXNlcklkOiBzdHJpbmcsIHJvbGVOYW1lczogc3RyaW5nW10pOiBPYnNlcnZhYmxlPGJvb2xlYW4+ICB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVzZXJSb2xlcyh1c2VySWQpLnBpcGUobWFwKCh1c2VyUm9sZXM6IElkZW50aXR5Um9sZU1vZGVsW10pID0+IHtcbiAgICAgICAgICAgIGxldCBoYXNSb2xlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodXNlclJvbGVzICYmIHVzZXJSb2xlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcm9sZU5hbWVzLmZvckVhY2goKHJvbGVOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm9sZSA9IHVzZXJSb2xlcy5maW5kKCh1c2VyUm9sZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvbGVOYW1lID09PSB1c2VyUm9sZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JvbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFzUm9sZTtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYnVpbGRVc2VyVXJsKCk6IGFueSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmFwcENvbmZpZ1NlcnZpY2UuZ2V0KCdpZGVudGl0eUhvc3QnKX0vdXNlcnNgO1xuICAgIH1cblxuICAgIHByaXZhdGUgYnVpbGRVc2VyQ2xpZW50Um9sZU1hcHBpbmcodXNlcklkOiBzdHJpbmcsIGNsaWVudElkOiBzdHJpbmcpOiBhbnkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5hcHBDb25maWdTZXJ2aWNlLmdldCgnaWRlbnRpdHlIb3N0Jyl9L3VzZXJzLyR7dXNlcklkfS9yb2xlLW1hcHBpbmdzL2NsaWVudHMvJHtjbGllbnRJZH1gO1xuICAgIH1cblxuICAgIHByaXZhdGUgYnVpbGRSb2xlc1VybCh1c2VySWQ6IHN0cmluZyk6IGFueSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmFwcENvbmZpZ1NlcnZpY2UuZ2V0KCdpZGVudGl0eUhvc3QnKX0vdXNlcnMvJHt1c2VySWR9L3JvbGUtbWFwcGluZ3MvcmVhbG0vY29tcG9zaXRlYDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGJ1aWxkR2V0Q2xpZW50c1VybCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuYXBwQ29uZmlnU2VydmljZS5nZXQoJ2lkZW50aXR5SG9zdCcpfS9jbGllbnRzYDtcbiAgICB9XG5cbn1cbiJdfQ==