/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { FileModel } from '@alfresco/adf-core';
import { EventEmitter, Input, Output } from '@angular/core';
import { UploadFilesEvent } from '../upload-files.event';
/**
 * @abstract
 */
var UploadBase = /** @class */ (function () {
    function UploadBase(uploadService, translationService, ngZone) {
        this.uploadService = uploadService;
        this.translationService = translationService;
        this.ngZone = ngZone;
        /**
         * The ID of the root. Use the nodeId for
         * Content Services or the taskId/processId for Process Services.
         */
        this.rootFolderId = '-root-';
        /**
         * Toggles component disabled state (if there is no node permission checking).
         */
        this.disabled = false;
        /**
         * Filter for accepted file types.
         */
        this.acceptedFilesType = '*';
        /**
         * Toggles versioning.
         */
        this.versioning = false;
        /**
         * majorVersion boolean field to true to indicate a major version should be created.
         */
        this.majorVersion = false;
        /**
         * Custom node type for uploaded file
         */
        this.nodeType = 'cm:content';
        /**
         * Emitted when the file is uploaded successfully.
         */
        this.success = new EventEmitter();
        /**
         * Emitted when an error occurs.
         */
        this.error = new EventEmitter();
        /**
         * Emitted when the upload begins.
         */
        this.beginUpload = new EventEmitter();
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    UploadBase.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscriptions.push(this.uploadService.fileUploadError.subscribe(function (error) {
            _this.error.emit(error);
        }));
    };
    /**
     * @return {?}
     */
    UploadBase.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (subscription) { return subscription.unsubscribe(); });
        this.subscriptions = [];
    };
    /**
     * Upload a list of file in the specified path
     * @param files
     * @param path
     */
    /**
     * Upload a list of file in the specified path
     * @param {?} files
     * @return {?}
     */
    UploadBase.prototype.uploadFiles = /**
     * Upload a list of file in the specified path
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        /** @type {?} */
        var filteredFiles = files
            .map(function (file) {
            return _this.createFileModel(file, _this.rootFolderId, (((/** @type {?} */ (file))).webkitRelativePath || '').replace(/\/[^\/]*$/, ''));
        });
        this.uploadQueue(filteredFiles);
    };
    /**
     * @param {?} files
     * @return {?}
     */
    UploadBase.prototype.uploadFilesInfo = /**
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        /** @type {?} */
        var filteredFiles = files
            .map(function (fileInfo) {
            return _this.createFileModel(fileInfo.file, _this.rootFolderId, fileInfo.relativeFolder);
        });
        this.uploadQueue(filteredFiles);
    };
    /**
     * @private
     * @param {?} files
     * @return {?}
     */
    UploadBase.prototype.uploadQueue = /**
     * @private
     * @param {?} files
     * @return {?}
     */
    function (files) {
        var _this = this;
        /** @type {?} */
        var filteredFiles = files
            .filter(this.isFileAcceptable.bind(this))
            .filter(this.isFileSizeAcceptable.bind(this));
        this.ngZone.run(function () {
            var _a;
            /** @type {?} */
            var event = new UploadFilesEvent(tslib_1.__spread(filteredFiles), _this.uploadService, _this.success);
            _this.beginUpload.emit(event);
            if (!event.defaultPrevented) {
                if (filteredFiles.length > 0) {
                    (_a = _this.uploadService).addToQueue.apply(_a, tslib_1.__spread(filteredFiles));
                    _this.uploadService.uploadFilesInTheQueue(_this.success);
                }
            }
        });
    };
    /**
     * Checks if the given file is allowed by the extension filters
     *
     * @param file FileModel
     */
    /**
     * Checks if the given file is allowed by the extension filters
     *
     * @protected
     * @param {?} file FileModel
     * @return {?}
     */
    UploadBase.prototype.isFileAcceptable = /**
     * Checks if the given file is allowed by the extension filters
     *
     * @protected
     * @param {?} file FileModel
     * @return {?}
     */
    function (file) {
        if (this.acceptedFilesType === '*') {
            return true;
        }
        /** @type {?} */
        var allowedExtensions = this.acceptedFilesType
            .split(',')
            .map(function (ext) { return ext.trim().replace(/^\./, ''); });
        if (allowedExtensions.indexOf(file.extension) !== -1) {
            return true;
        }
        return false;
    };
    /**
     * Creates FileModel from File
     *
     * @param file
     */
    /**
     * Creates FileModel from File
     *
     * @protected
     * @param {?} file
     * @param {?} parentId
     * @param {?} path
     * @param {?=} id
     * @return {?}
     */
    UploadBase.prototype.createFileModel = /**
     * Creates FileModel from File
     *
     * @protected
     * @param {?} file
     * @param {?} parentId
     * @param {?} path
     * @param {?=} id
     * @return {?}
     */
    function (file, parentId, path, id) {
        return new FileModel(file, {
            comment: this.comment,
            majorVersion: this.majorVersion,
            newVersion: this.versioning,
            parentId: parentId,
            path: path,
            nodeType: this.nodeType
        }, id);
    };
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    UploadBase.prototype.isFileSizeAllowed = /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    function (file) {
        /** @type {?} */
        var isFileSizeAllowed = true;
        if (this.isMaxFileSizeDefined()) {
            isFileSizeAllowed = this.isFileSizeCorrect(file);
        }
        return isFileSizeAllowed;
    };
    /**
     * @protected
     * @return {?}
     */
    UploadBase.prototype.isMaxFileSizeDefined = /**
     * @protected
     * @return {?}
     */
    function () {
        return this.maxFilesSize !== undefined && this.maxFilesSize !== null;
    };
    /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    UploadBase.prototype.isFileSizeCorrect = /**
     * @protected
     * @param {?} file
     * @return {?}
     */
    function (file) {
        return this.maxFilesSize >= 0 && file.size <= this.maxFilesSize;
    };
    /**
     * Checks if the given file is an acceptable size
     *
     * @param file FileModel
     */
    /**
     * Checks if the given file is an acceptable size
     *
     * @private
     * @param {?} file FileModel
     * @return {?}
     */
    UploadBase.prototype.isFileSizeAcceptable = /**
     * Checks if the given file is an acceptable size
     *
     * @private
     * @param {?} file FileModel
     * @return {?}
     */
    function (file) {
        /** @type {?} */
        var acceptableSize = true;
        if (!this.isFileSizeAllowed(file)) {
            acceptableSize = false;
            /** @type {?} */
            var message = this.translationService.instant('FILE_UPLOAD.MESSAGES.EXCEED_MAX_FILE_SIZE', { fileName: file.name });
            this.error.emit(message);
        }
        return acceptableSize;
    };
    UploadBase.propDecorators = {
        maxFilesSize: [{ type: Input }],
        rootFolderId: [{ type: Input }],
        disabled: [{ type: Input }],
        acceptedFilesType: [{ type: Input }],
        versioning: [{ type: Input }],
        majorVersion: [{ type: Input }],
        comment: [{ type: Input }],
        nodeType: [{ type: Input }],
        success: [{ type: Output }],
        error: [{ type: Output }],
        beginUpload: [{ type: Output }]
    };
    return UploadBase;
}());
export { UploadBase };
if (false) {
    /**
     * Sets a limit on the maximum size (in bytes) of a file to be uploaded.
     * Has no effect if undefined.
     * @type {?}
     */
    UploadBase.prototype.maxFilesSize;
    /**
     * The ID of the root. Use the nodeId for
     * Content Services or the taskId/processId for Process Services.
     * @type {?}
     */
    UploadBase.prototype.rootFolderId;
    /**
     * Toggles component disabled state (if there is no node permission checking).
     * @type {?}
     */
    UploadBase.prototype.disabled;
    /**
     * Filter for accepted file types.
     * @type {?}
     */
    UploadBase.prototype.acceptedFilesType;
    /**
     * Toggles versioning.
     * @type {?}
     */
    UploadBase.prototype.versioning;
    /**
     * majorVersion boolean field to true to indicate a major version should be created.
     * @type {?}
     */
    UploadBase.prototype.majorVersion;
    /**
     * When you overwrite existing content, you can use the comment field to add a version comment that appears in the version history
     * @type {?}
     */
    UploadBase.prototype.comment;
    /**
     * Custom node type for uploaded file
     * @type {?}
     */
    UploadBase.prototype.nodeType;
    /**
     * Emitted when the file is uploaded successfully.
     * @type {?}
     */
    UploadBase.prototype.success;
    /**
     * Emitted when an error occurs.
     * @type {?}
     */
    UploadBase.prototype.error;
    /**
     * Emitted when the upload begins.
     * @type {?}
     */
    UploadBase.prototype.beginUpload;
    /**
     * @type {?}
     * @protected
     */
    UploadBase.prototype.subscriptions;
    /**
     * @type {?}
     * @protected
     */
    UploadBase.prototype.uploadService;
    /**
     * @type {?}
     * @protected
     */
    UploadBase.prototype.translationService;
    /**
     * @type {?}
     * @protected
     */
    UploadBase.prototype.ngZone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBsb2FkLWJhc2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvbnRlbnQtc2VydmljZXMvIiwic291cmNlcyI6WyJ1cGxvYWQvY29tcG9uZW50cy9iYXNlLXVwbG9hZC91cGxvYWQtYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFFLFNBQVMsRUFBWSxNQUFNLG9CQUFvQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBNkIsTUFBTSxlQUFlLENBQUM7QUFHdkYsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7Ozs7QUFFekQ7SUFvREksb0JBQXNCLGFBQTRCLEVBQzVCLGtCQUFzQyxFQUN0QyxNQUFjO1FBRmQsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtRQUN0QyxXQUFNLEdBQU4sTUFBTSxDQUFROzs7OztRQTFDcEMsaUJBQVksR0FBVyxRQUFRLENBQUM7Ozs7UUFJaEMsYUFBUSxHQUFZLEtBQUssQ0FBQzs7OztRQUkxQixzQkFBaUIsR0FBVyxHQUFHLENBQUM7Ozs7UUFJaEMsZUFBVSxHQUFZLEtBQUssQ0FBQzs7OztRQUk1QixpQkFBWSxHQUFZLEtBQUssQ0FBQzs7OztRQVE5QixhQUFRLEdBQVcsWUFBWSxDQUFDOzs7O1FBSWhDLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDOzs7O1FBSTdCLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDOzs7O1FBSTNCLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQW9CLENBQUM7UUFFekMsa0JBQWEsR0FBbUIsRUFBRSxDQUFDO0lBSzdDLENBQUM7Ozs7SUFFRCw2QkFBUTs7O0lBQVI7UUFBQSxpQkFPQztRQU5HLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUNuQixJQUFJLENBQUMsYUFBYSxD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Ozs7Ozs7O0lBQ0sseUNBQW9COzs7Ozs7O0lBQTVCLFVBQTZCLElBQWU7O1lBQ3BDLGNBQWMsR0FBRyxJQUFJO1FBRXpCLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDL0IsY0FBYyxHQUFHLEtBQUssQ0FBQzs7Z0JBRWpCLE9BQU8sR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUMzQywyQ0FBMkMsRUFDM0MsRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUMxQjtZQUVELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQzVCO1FBRUQsT0FBTyxjQUFjLENBQUM7SUFDMUIsQ0FBQzs7K0JBekxBLEtBQUs7K0JBTUwsS0FBSzsyQkFJTCxLQUFLO29DQUlMLEtBQUs7NkJBSUwsS0FBSzsrQkFJTCxLQUFLOzBCQUlMLEtBQUs7MkJBSUwsS0FBSzswQkFJTCxNQUFNO3dCQUlOLE1BQU07OEJBSU4sTUFBTTs7SUFpSlgsaUJBQUM7Q0FBQSxBQWhNRCxJQWdNQztTQWhNcUIsVUFBVTs7Ozs7OztJQUs1QixrQ0FDcUI7Ozs7OztJQUtyQixrQ0FDZ0M7Ozs7O0lBR2hDLDhCQUMwQjs7Ozs7SUFHMUIsdUNBQ2dDOzs7OztJQUdoQyxnQ0FDNEI7Ozs7O0lBRzVCLGtDQUM4Qjs7Ozs7SUFHOUIsNkJBQ2dCOzs7OztJQUdoQiw4QkFDZ0M7Ozs7O0lBR2hDLDZCQUM2Qjs7Ozs7SUFHN0IsMkJBQzJCOzs7OztJQUczQixpQ0FDbUQ7Ozs7O0lBRW5ELG1DQUE2Qzs7Ozs7SUFFakMsbUNBQXNDOzs7OztJQUN0Qyx3Q0FBZ0Q7Ozs7O0lBQ2hELDRCQUF3QiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZpbGVNb2RlbCwgRmlsZUluZm8gfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBPbkluaXQsIE9uRGVzdHJveSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGxvYWRTZXJ2aWNlLCBUcmFuc2xhdGlvblNlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBVcGxvYWRGaWxlc0V2ZW50IH0gZnJvbSAnLi4vdXBsb2FkLWZpbGVzLmV2ZW50JztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFVwbG9hZEJhc2UgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKiogU2V0cyBhIGxpbWl0IG9uIHRoZSBtYXhpbXVtIHNpemUgKGluIGJ5dGVzKSBvZiBhIGZpbGUgdG8gYmUgdXBsb2FkZWQuXG4gICAgICogSGFzIG5vIGVmZmVjdCBpZiB1bmRlZmluZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtYXhGaWxlc1NpemU6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgSUQgb2YgdGhlIHJvb3QuIFVzZSB0aGUgbm9kZUlkIGZvclxuICAgICAqIENvbnRlbnQgU2VydmljZXMgb3IgdGhlIHRhc2tJZC9wcm9jZXNzSWQgZm9yIFByb2Nlc3MgU2VydmljZXMuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByb290Rm9sZGVySWQ6IHN0cmluZyA9ICctcm9vdC0nO1xuXG4gICAgLyoqIFRvZ2dsZXMgY29tcG9uZW50IGRpc2FibGVkIHN0YXRlIChpZiB0aGVyZSBpcyBubyBub2RlIHBlcm1pc3Npb24gY2hlY2tpbmcpLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBGaWx0ZXIgZm9yIGFjY2VwdGVkIGZpbGUgdHlwZXMuICovXG4gICAgQElucHV0KClcbiAgICBhY2NlcHRlZEZpbGVzVHlwZTogc3RyaW5nID0gJyonO1xuXG4gICAgLyoqIFRvZ2dsZXMgdmVyc2lvbmluZy4gKi9cbiAgICBASW5wdXQoKVxuICAgIHZlcnNpb25pbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBtYWpvclZlcnNpb24gYm9vbGVhbiBmaWVsZCB0byB0cnVlIHRvIGluZGljYXRlIGEgbWFqb3IgdmVyc2lvbiBzaG91bGQgYmUgY3JlYXRlZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIG1ham9yVmVyc2lvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIFdoZW4geW91IG92ZXJ3cml0ZSBleGlzdGluZyBjb250ZW50LCB5b3UgY2FuIHVzZSB0aGUgY29tbWVudCBmaWVsZCB0byBhZGQgYSB2ZXJzaW9uIGNvbW1lbnQgdGhhdCBhcHBlYXJzIGluIHRoZSB2ZXJzaW9uIGhpc3RvcnkgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbW1lbnQ6IHN0cmluZztcblxuICAgIC8qKiBDdXN0b20gbm9kZSB0eXBlIGZvciB1cGxvYWRlZCBmaWxlICovXG4gICAgQElucHV0KClcbiAgICBub2RlVHlwZTogc3RyaW5nID0gJ2NtOmNvbnRlbnQnO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgZmlsZSBpcyB1cGxvYWRlZCBzdWNjZXNzZnVsbHkuICovXG4gICAgQE91dHB1dCgpXG4gICAgc3VjY2VzcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGVycm9yID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgdXBsb2FkIGJlZ2lucy4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBiZWdpblVwbG9hZCA9IG5ldyBFdmVudEVtaXR0ZXI8VXBsb2FkRmlsZXNFdmVudD4oKTtcblxuICAgIHByb3RlY3RlZCBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHVwbG9hZFNlcnZpY2U6IFVwbG9hZFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHRyYW5zbGF0aW9uU2VydmljZTogVHJhbnNsYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBuZ1pvbmU6IE5nWm9uZSkge1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgICAgIHRoaXMudXBsb2FkU2VydmljZS5maWxlVXBsb2FkRXJyb3Iuc3Vic2NyaWJlKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnJvcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWJzY3JpcHRpb24pID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBsb2FkIGEgbGlzdCBvZiBmaWxlIGluIHRoZSBzcGVjaWZpZWQgcGF0aFxuICAgICAqIEBwYXJhbSBmaWxlc1xuICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICovXG4gICAgdXBsb2FkRmlsZXMoZmlsZXM6IEZpbGVbXSk6IHZvaWQge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZEZpbGVzOiBGaWxlTW9kZWxbXSA9IGZpbGVzXG4gICAgICAgICAgICAubWFwPEZpbGVNb2RlbD4oKGZpbGU6IEZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGaWxlTW9kZWwoZmlsZSwgdGhpcy5yb290Rm9sZGVySWQsICgoPGFueT4gZmlsZSkud2Via2l0UmVsYXRpdmVQYXRoIHx8ICcnKS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sICcnKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnVwbG9hZFF1ZXVlKGZpbHRlcmVkRmlsZXMpO1xuICAgIH1cblxuICAgIHVwbG9hZEZpbGVzSW5mbyhmaWxlczogRmlsZUluZm9bXSk6IHZvaWQge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZEZpbGVzOiBGaWxlTW9kZWxbXSA9IGZpbGVzXG4gICAgICAgICAgICAubWFwPEZpbGVNb2RlbD4oKGZpbGVJbmZvOiBGaWxlSW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZpbGVNb2RlbChmaWxlSW5mby5maWxlLCB0aGlzLnJvb3RGb2xkZXJJZCwgZmlsZUluZm8ucmVsYXRpdmVGb2xkZXIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy51cGxvYWRRdWV1ZShmaWx0ZXJlZEZpbGVzKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwbG9hZFF1ZXVlKGZpbGVzOiBGaWxlTW9kZWxbXSkge1xuICAgICAgICBsZXQgZmlsdGVyZWRGaWxlcyA9IGZpbGVzXG4gICAgICAgICAgICAuZmlsdGVyKHRoaXMuaXNGaWxlQWNjZXB0YWJsZS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLmZpbHRlcih0aGlzLmlzRmlsZVNpemVBY2NlcHRhYmxlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBVcGxvYWRGaWxlc0V2ZW50KFxuICAgICAgICAgICAgICAgIFsuLi5maWx0ZXJlZEZpbGVzXSxcbiAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgdGhpcy5zdWNjZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5iZWdpblVwbG9hZC5lbWl0KGV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZFNlcnZpY2UuYWRkVG9RdWV1ZSguLi5maWx0ZXJlZEZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGxvYWRTZXJ2aWNlLnVwbG9hZEZpbGVzSW5UaGVRdWV1ZSh0aGlzLnN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBmaWxlIGlzIGFsbG93ZWQgYnkgdGhlIGV4dGVuc2lvbiBmaWx0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZSBGaWxlTW9kZWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaXNGaWxlQWNjZXB0YWJsZShmaWxlOiBGaWxlTW9kZWwpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuYWNjZXB0ZWRGaWxlc1R5cGUgPT09ICcqJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhbGxvd2VkRXh0ZW5zaW9ucyA9IHRoaXMuYWNjZXB0ZWRGaWxlc1R5cGVcbiAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAubWFwKChleHQpID0+IGV4dC50cmltKCkucmVwbGFjZSgvXlxcLi8sICcnKSk7XG5cbiAgICAgICAgaWYgKGFsbG93ZWRFeHRlbnNpb25zLmluZGV4T2YoZmlsZS5leHRlbnNpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBGaWxlTW9kZWwgZnJvbSBGaWxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVGaWxlTW9kZWwoZmlsZTogRmlsZSwgcGFyZW50SWQ6IHN0cmluZywgcGF0aDogc3RyaW5nLCBpZD86IHN0cmluZyk6IEZpbGVNb2RlbCB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsZU1vZGVsKGZpbGUsIHtcbiAgICAgICAgICAgIGNvbW1lbnQ6IHRoaXMuY29tbWVudCxcbiAgICAgICAgICAgIG1ham9yVmVyc2lvbjogdGhpcy5tYWpvclZlcnNpb24sXG4gICAgICAgICAgICBuZXdWZXJzaW9uOiB0aGlzLnZlcnNpb25pbmcsXG4gICAgICAgICAgICBwYXJlbnRJZDogcGFyZW50SWQsXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgbm9kZVR5cGU6IHRoaXMubm9kZVR5cGVcbiAgICAgICAgfSwgaWQpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBpc0ZpbGVTaXplQWxsb3dlZChmaWxlOiBGaWxlTW9kZWwpIHtcbiAgICAgICAgbGV0IGlzRmlsZVNpemVBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXhGaWxlU2l6ZURlZmluZWQoKSkge1xuICAgICAgICAgICAgaXNGaWxlU2l6ZUFsbG93ZWQgPSB0aGlzLmlzRmlsZVNpemVDb3JyZWN0KGZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzRmlsZVNpemVBbGxvd2VkO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBpc01heEZpbGVTaXplRGVmaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RmlsZXNTaXplICE9PSB1bmRlZmluZWQgJiYgdGhpcy5tYXhGaWxlc1NpemUgIT09IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGlzRmlsZVNpemVDb3JyZWN0KGZpbGU6IEZpbGVNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhGaWxlc1NpemUgPj0gMCAmJiBmaWxlLnNpemUgPD0gdGhpcy5tYXhGaWxlc1NpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBmaWxlIGlzIGFuIGFjY2VwdGFibGUgc2l6ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgRmlsZU1vZGVsXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0ZpbGVTaXplQWNjZXB0YWJsZShmaWxlOiBGaWxlTW9kZWwpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGFjY2VwdGFibGVTaXplID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNGaWxlU2l6ZUFsbG93ZWQoZmlsZSkpIHtcbiAgICAgICAgICAgIGFjY2VwdGFibGVTaXplID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLnRyYW5zbGF0aW9uU2VydmljZS5pbnN0YW50KFxuICAgICAgICAgICAgICAgICdGSUxFX1VQTE9BRC5NRVNTQUdFUy5FWENFRURfTUFYX0ZJTEVfU0laRScsXG4gICAgICAgICAgICAgICAgeyBmaWxlTmFtZTogZmlsZS5uYW1lIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY2NlcHRhYmxlU2l6ZTtcbiAgICB9XG5cbn1cbiJdfQ==